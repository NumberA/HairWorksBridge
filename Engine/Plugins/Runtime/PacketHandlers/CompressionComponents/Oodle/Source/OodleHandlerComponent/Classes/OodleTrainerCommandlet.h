// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Commandlets/Commandlet.h"

#include "OodleTrainerCommandlet.generated.h"


/**
 * Commandlet for processing UE4 packet captures, through Oodle's training API, for generating compressed state dictionaries.
 *
 *
 * Primary Commands:
 *	- "AutoGenerateDictionaries":
 *		- Iterates every directory within "*Game*\Saved\Oodle\Server", and uses all capture files within each directory,
 *			to generate a dictionary stored in "*Game*\Content\Oodle", named "*Game**DirectoryName*.udic".
 *
 *		- For example, packet captures in "OrionGame\Saved\Oodle\Server\Input", will be generated into a dictionary stored in
 *			"OrionGame\Content\Oodle\OrionGameInput.udic"
 *
 *		- Each folder within "*Game*\Content\Oodle", should contain at least 100mb of packet captures.
 *
 *		- @todo #JohnB: Document commandline switches
 *
 *
 * Secondary/Testing Commands:
 *	- "Enable":
 *		- Inserts the Oodle PacketHandler into the games packet handler component list, and initializes Oodle *Engine.ini settings
 *
 *
 *	- "MergePackets OutputFile PacketFile1,PacketFile2,PacketFileN":
 *		- Takes the specified packet capture files, and merges them into a single packet capture file
 *
 *	- "MergePackets OutputFile All Directory":
 *		- As above, but merges all capture files in the specified directory.
 *
 *
 *	- "GenerateDictionary OutputFile PacketFile1,PacketFile2,PacketFileN":
 *		- Takes the specified packet capture files, and uses them to generate a network compression dictionary
 *
 *	- "GenerateDictionary OutputFile All Directory":
 *		- As above, but uses all capture files in the specified directory, to generate a network compression dictionary
 *
 *
 * @todo #JohnB: Unimplemented commands:
 *	- "PacketInfo PacketFile":
 *		- Outputs information about the packet file, such as the MB amount of data recorded, per net connection channel, and data types
 *		- @todo #JohnB: Only implement, if deciding to actually capture/track this kind of data
 */
UCLASS()
class UOodleTrainerCommandlet : public UCommandlet
{
	GENERATED_UCLASS_BODY()

public:
	virtual int32 Main(const FString& Params) override;

#if HAS_OODLE_SDK
	/**
	 * Handles the 'enable' command, which enables the Oodle packet handler component
	 *
	 * @return	Whether or not the command executed successfully
	 */
	static bool HandleEnable();

#if !UE_BUILD_SHIPPING || OODLE_DEV_SHIPPING
	/**
	 * Handles the 'MergePackets' command, which is used to merge multiple packet capture files
	 *
	 * @param OutputCapFile		The file which will contain the merged packets
	 * @param MergeList			The list of packet capture files to merge, or if bMergeAll, the directory containing these files
	 * @param bMergeAll			Whether or not MergeList refers to a directory, where all of the files it contains should be merged
	 * @return					Whether or not the command executed successfully
	 */
	bool HandleMergePackets(FString OutputCapFile, FString MergeList, bool bMergeAll=false);


	/**
	 * Handles the 'AutoGenerateDictionaries' command, which is used to automatically detect packet captures and produce dictionaries
	 *
	 * This is done, by iterating every directory within "*Game*\Saved\Oodle\Server", and using all capture files within each directory,
	 * to generate a dictionary name "*Game**DirectoryName*.udic", stored in "*Game*\Content\Oodle".
	 *
	 * For example, captures in "OrionGame\Saved\Oodle\Server\Input", generate "OrionGame\Content\Oodle\OrionGameInput.udic".
	 *
	 * @return	Whether or not the command executed successfully
	 */
	bool HandleAutoGenerateDictionaries();



	/**
	 * Converts a list of capture files to merge, into a map of file archives vs file names (doing all necessary verification etc.)
	 * NOTE: OutMergeMap FArchive*'s must be deleted by the caller.
	 *
	 * @param MergeList			The list of capture files to merge (or the directory containing files to merge, if bMergeAll)
	 * @param OutMergeMap		The output map of file archives vs file names
	 * @param bMergeAll			If true, merges all capture files in the specified directory (with MergeList pointing to a directory)
	 * @param bAllowSingleFile	Whether or not the function will error when only a single file is found
	 * @return					Whether or not the list was successfully parsed, and merge map successfully assigned
	 */
	static bool GetMergeMapFromList(FString MergeList, TMap<FArchive*, FString>& OutMergeMap, bool bMergeAll=false,
									bool bAllowSingleFile=false);

	/**
	 * Checks that the output file does not already exist, and prompts for an overwrite, if it does
	 *
	 * @param OutputFile	The output file string
	 * @return				Whether or not OutputFile is a valid path
	 */
	static bool VerifyOutputFile(FString OutputFile);
#endif // HAS_OODLE_SDK
#endif // !UE_BUILD_SHIPPING || OODLE_DEV_SHIPPING
};


#if HAS_OODLE_SDK && (!UE_BUILD_SHIPPING || OODLE_DEV_SHIPPING)
/**
 * FOodleDictionaryGenerator
 *
 * This class encapsulates dictionary generation, and splits it into multiple stages for readability
 */
class FOodleDictionaryGenerator
{
	/** Input/Parameter variables */
private:
	/** The path for outputting the generated dictionary */
	FString OutputDictionaryFile;

	/** Whether or not compression testing should be performed after dictionary generation (uses up some of the packets) */
	bool bCompressionTestPackets;

	/** Size of the hash table to use for the dictionary */
	int32 HashTableSize;

	/** Size of the dictionary to be generated */
	int32 DictionarySize;

	/** The number of random packet-selection trials to run, when generating the dictionary, to try and optimize the dictionary */
	int32 DictionaryTrials;

	/** The randomness, in percent, of random packet-selection trials */
	int32 TrialRandomness;

	/** The number of generations of random packet-selection trials  */
	// @todo #JohnB: Examine this more closely, and document better (see email from Charles on 20/11/15)
	int32 TrialGenerations;

	/** Whether or not random-trials have been disabled */
	bool bNoTrials;


	/** Runtime variables (Opaque) */
private:
	TMap<FArchive*, FString> MergeMap;


	TArray<uint8*>	DictionaryPackets;
	TArray<S32>		DictionaryPacketSizes;
	uint32			DictionaryPacketBytes;
	TArray<uint8*>	DictionaryTestPackets;
	TArray<S32>		DictionaryTestPacketSizes;
	uint32			DictionaryTestPacketBytes;
	TArray<uint8*>	TrainerPackets;
	TArray<S32>		TrainerPacketSizes;
	uint32			TrainerPacketBytes;
	TArray<uint8*>	CompressionTestPackets;
	TArray<S32>		CompressionTestPacketSizes;
	uint32			CompressionTestPacketBytes;

	bool bDictionaryTestOverflow;

public:
	/**
	 * Base constructor
	 */
	FOodleDictionaryGenerator()
		: OutputDictionaryFile()
		, bCompressionTestPackets(false)
		, HashTableSize(19)
		, DictionarySize(4 * 1024 * 1024)
		, DictionaryTrials(3)
		, TrialRandomness(200)
		, TrialGenerations(1)
		, bNoTrials(false)
		, MergeMap()
		, DictionaryPacketBytes(0)
		, DictionaryTestPacketBytes(0)
		, TrainerPacketBytes(0)
		, CompressionTestPacketBytes(0)
		, bDictionaryTestOverflow(false)
	{
	}

	/**
	 * Primary function handling generation of the dictionary
	 *
	 * @param InOutputDictionaryFile	The path for the final dictionary file
	 * @param InputCaptureFiles			The capture file to process, or if bMergeAll, the directory where all captures files are located
	 * @param bMergeAll					Whether or not to merge all capture files, in the folder specified by InputCaptureFiles
	 * @return							Whether or not the dictionary generation was successful
	 */
	bool BeginGenerateDictionary(FString InOutputDictionaryFile, FString InputCaptureFiles, bool bMergeAll);


private:
	/**
	 * Initialize the dictionary generate parameters and state
	 *
	 * @return	Whether or not initialization was successful
	 */
	bool InitGenerator();

	/**
	 * Reads the specified capture files, and loads/sorts them in memory, in preparation for processing
	 *
	 * @param InputCaptureFiles		As per BeginGenerateDictionary
	 * @param bMergeAll				As per BeginGenerateDictionary
	 * @return						Whether or not packet reading was successful
	 */
	bool ReadPackets(FString InputCaptureFiles, bool bMergeAll);

	/**
	 * Processes loaded packet data through the Oodle dictionary generation API, and then writes/compresses the result to the final file
	 *
	 * @return	Whether or not final dictionary generation was successful
	 */
	bool GenerateAndWriteDictionary();

	/**
	 * Cleans up any leftover allocated memory
	 */
	void Cleanup();
};
#endif
