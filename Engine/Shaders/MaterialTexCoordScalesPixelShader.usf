// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	MaterialTexCoordScalesPixelShader.usf: Pixel shader to analyse coordinate scale per texture
=============================================================================*/

#define TEX_COORD_SCALE_ANALYSIS 1
#define DEBUG_MATERIAL_PARAMETERS 1

#include "Common.usf"
#include "SHCommon.usf"

 // If -1, output everything to the RW texture.
float4 AccuracyColors[5];
uint TextureAnalysisIndex;

float4 OneOverCPUTexCoordScales[MAX_NUM_TEXTURE_REGISTER / 4];
int4 TexCoordIndices[MAX_NUM_TEXTURE_REGISTER / 4];

float GetComponent(float4 V, int Index)
{
	FLATTEN
	if (Index == 0) return V.x;
	FLATTEN
	if (Index == 1) return V.y;
	FLATTEN
	if (Index == 2) return V.z;
	return V.w;
}

struct FTexCoordScalesParams
{
	// Global var used to reduce the number of param passed to the shaders.
	uint2 PixelPosition;

	// ddU, ddV for each coord index (up to 4 currently)
	float4 OneOverDDU;
	float4 OneOverDDV;

	// Used when inspecting single elements.
	float MinScale;
	float MaxScale;

	float TexSample;

	// When computing the texture scales, this holds 4 scales for consecutive texture register indices.
	float4 ScalesPerIndex;
};

MaterialFloat StoreTexCoordScale(in out FTexCoordScalesParams Params, float2 UV, uniform uint TextureReferenceIndex)
{
	// Take the minimum scale since high scale requires less resolution.
	float GPUScaleX = length(ddx(UV));
	float GPUScaleY = length(ddy(UV));

	if (TextureReferenceIndex >= 0 && TextureReferenceIndex < MAX_NUM_TEXTURE_REGISTER)
	{
		float OneOverCPUScale = OneOverCPUTexCoordScales[TextureReferenceIndex / 4][TextureReferenceIndex % 4];

		int TexCoordIndex = TexCoordIndices[TextureReferenceIndex / 4][TextureReferenceIndex % 4];
		
		float GPUScale = min(GPUScaleX * GetComponent(Params.OneOverDDU, TexCoordIndex), GPUScaleY * GetComponent(Params.OneOverDDV, TexCoordIndex));

		// Code path when searching the worst scales
		const bool bUpdateMinMax = (OneOverCPUScale > 0 && (TextureAnalysisIndex == MAX_NUM_TEXTURE_REGISTER || TextureAnalysisIndex == TextureReferenceIndex));
		Params.MinScale = bUpdateMinMax ? min(Params.MinScale, GPUScale * OneOverCPUScale) : Params.MinScale;
		Params.MaxScale = bUpdateMinMax ? max(Params.MaxScale, GPUScale * OneOverCPUScale) : Params.MaxScale;

		// Code path when rendering the material in a render target. Each TILE_RESOLUTION X TILE_RESOLUTION maps to different texture.
		const bool bUpdateScale = (TextureAnalysisIndex == -1 && Params.PixelPosition.x / TILE_RESOLUTION == TextureReferenceIndex / 4) ;
		Params.ScalesPerIndex[TextureReferenceIndex % 4] = bUpdateScale ? min(Params.ScalesPerIndex[TextureReferenceIndex % 4], GPUScale) : Params.ScalesPerIndex[TextureReferenceIndex % 4];
	}
	return 1.f;
}

MaterialFloat StoreTexSample(in out FTexCoordScalesParams Params, float4 C, uniform uint TextureReferenceIndex)
{
	// Alpha?
	Params.TexSample = TextureAnalysisIndex == TextureReferenceIndex ? lerp(.4f, 1.f, saturate(Luminance(C.rgb))) : Params.TexSample;

	return 1.f;
}

#include "Material.usf"
#include "DebugViewModeCommon.usf"

void Main(
	in FDebugPSIn DebugInputs
	OPTIONAL_IsFrontFace,
	out float4 OutColor : SV_Target0
	)
{
#if INSTANCED_STEREO
	ResolvedView = ResolveView(DebugInputs.EyeIndex);
#else
	ResolvedView = ResolveView();
#endif

	// This default value will make it dark grey when nothing updates the texSample.
	float3 Result = float3(.02, .02, .02);

	FTexCoordScalesParams Params;

	// Set global var used for outputting data
	Params.PixelPosition = DebugInputs.SvPosition;
	Params.OneOverDDU = 1 / float4(length(ddx(DebugInputs.TexCoord01.xy)), length(ddx(DebugInputs.TexCoord01.zw)), length(ddx(DebugInputs.TexCoord23.xy)), length(ddx(DebugInputs.TexCoord23.zw)));
	Params.OneOverDDV = 1 / float4(length(ddy(DebugInputs.TexCoord01.xy)), length(ddy(DebugInputs.TexCoord01.zw)), length(ddy(DebugInputs.TexCoord23.xy)), length(ddy(DebugInputs.TexCoord23.zw)));

	Params.TexSample = 1.f;
	Params.MinScale = INITIAL_GPU_SCALE;
	Params.MaxScale = 0;
	Params.ScalesPerIndex = INITIAL_GPU_SCALE;

	FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(DebugInputs, DebugInputs.SvPosition);

	// This is used to patch invalid parameters when computing the scales with FMeshMaterialRenderItem::EnqueueMaterialRender
	FLATTEN
	if (TextureAnalysisIndex == -1)
	{
		// @TODO : The quad vertex data has invalid tangent space for some reason, even though the code in FMeshMaterialRenderItem::FillQuadData looks like setting it right.
		MaterialParameters.TangentToWorld = float3x3(1,0,0,0,1,0,0,0,1);

		// The next line ensures a constant view vector of (0,0,1) for all pixels. Required because here SVPositionToTranslatedWorld is identity, making excessive view angle increase per pixel.
		// That creates bad side effects for anything that depends on the view vector, like parallax or bump offset mappings. For those, we want the tangent
		// space view vector to be perpendicular to the surface in order to generate the same results as if the feature was turned off. Which gives the good results
		// since any sub height sampling would in pratice requires less and less texture resolution, where as we are only concerned about the highest resolution the material needs.
		// This can be seen in the debug view mode, by a checkboard of white and cyan (up to green) values. The white value meaning the highest resolution taken is the good one
		// (blue meaning the texture has more resolution than required). Checkboard are only possible when a texture is sampled several times, like in parallax.
		//
		// Additionnal to affecting the view vector, it also forces a constant world position value, zeroing any textcoord scales that depends on the world position (as the UV don't change).
		// This is alright thought since the uniform quad can obviously not compute a valid mapping for world space texture mapping (only rendering the mesh at its world position could fix that).
		// The zero scale will be caught as an error, and the computed scale will fallback to 1.f
		ResolvedView.SVPositionToTranslatedWorld = float4x4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1);

#if NUM_MATERIAL_TEXCOORDS > 0
		// Set all texcoord but one to 0. This allows the analysis to figure out which texcoord is driving the lookup.
		int CurrentCoordIndex = (Params.PixelPosition.y / TILE_RESOLUTION) % MAX_NUM_TEX_COORD;

		UNROLL
		for(int CoordinateIndex = 0; CoordinateIndex < NUM_MATERIAL_TEXCOORDS; ++CoordinateIndex)
		{
			// The quad material used only has a valid TexCoord for UV 0
			MaterialParameters.TexCoords[CoordinateIndex] = CoordinateIndex != CurrentCoordIndex ? 0 : DebugInputs.TexCoord01.xy;
		}
#endif
	}	

	half3 BaseColor;
	MaterialParameters.TexCoordScalesParams = Params;
	{
		FPixelMaterialInputs PixelMaterialInputs;
		CalcMaterialParameters(MaterialParameters, PixelMaterialInputs, DebugInputs.SvPosition, bIsFrontFace);

		// Sample material properties. The results are not used, but the calls to StoreTexCoordScale are still be made.
		BaseColor = GetMaterialBaseColor(PixelMaterialInputs);
		half  Metallic = GetMaterialMetallic(PixelMaterialInputs);
		half  Specular = GetMaterialSpecular(PixelMaterialInputs);
		float Roughness = GetMaterialRoughness(PixelMaterialInputs);
		half3 Emissive = GetMaterialEmissive(PixelMaterialInputs);
		half Opacity = GetMaterialOpacity(PixelMaterialInputs);
		half Mask = GetMaterialMask(PixelMaterialInputs);
		half4 SSData = GetMaterialSubsurfaceData(MaterialParameters);
		float Custom0 = GetMaterialCustomData0(MaterialParameters);
		float Custom1 = GetMaterialCustomData1(MaterialParameters);
		float MaterialAO = GetMaterialAmbientOcclusion(PixelMaterialInputs);
		float PixelDepthOffset = GetMaterialPixelDepthOffset(PixelMaterialInputs);
	}
	Params = MaterialParameters.TexCoordScalesParams;

	if (TextureAnalysisIndex == -1)
	{
		// Output the scales
		OutColor = Params.ScalesPerIndex;
	}
	else
	{
		float PixelScale = (Params.PixelPosition.x & 0x08) == (Params.PixelPosition.y & 0x08) ? Params.MinScale : Params.MaxScale;

		// Output accuracy. If the GPU Scale is INITIAL_GPU_SCALE, then the texcoord was not updated.
		if (Params.MinScale != INITIAL_GPU_SCALE)
		{
			Params.TexSample = TextureAnalysisIndex == MAX_NUM_TEXTURE_REGISTER ? lerp(.4f, 1.f, saturate(Luminance(BaseColor))) : Params.TexSample;

			float Accuracy = clamp(log2(PixelScale), -1.99, 1.99);
			int ColorIndex = floor(Accuracy) + 2;
			Result = Params.TexSample * lerp(AccuracyColors[ColorIndex].rgb, AccuracyColors[ColorIndex + 1].rgb, frac(Accuracy));
		}

		OutColor = RETURN_COLOR(float4(Result, .25f));
	}
}






