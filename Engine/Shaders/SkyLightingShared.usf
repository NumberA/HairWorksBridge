// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	SkyLightingShared.usf
=============================================================================*/

float ApproximateConeConeIntersection(float ArcLength0, float ArcLength1, float AngleBetweenCones)
{
	float AngleDifference = abs(ArcLength0 - ArcLength1);

	float Intersection = smoothstep(
		0,
		1.0,
		1.0 - saturate((AngleBetweenCones - AngleDifference) / (ArcLength0 + ArcLength1 - AngleDifference)));

	return Intersection;
}

Texture2D BentNormalAOTexture;
SamplerState BentNormalAOSampler;

float ApplyBentNormalAO;
float InvSkySpecularOcclusionStrength;
float MinSkySpecularOcclusion;

void GetDistanceFieldAOSpecularOcclusion(float2 ScreenUV, float3 ReflectionVector, float Roughness, bool bTwoSidedFoliage, out float IndirectSpecularOcclusion, out float IndirectDiffuseOcclusion)
{
	IndirectSpecularOcclusion = 1;
	IndirectDiffuseOcclusion = 1;

	BRANCH
	if (ApplyBentNormalAO > 0)
	{
		float4 TextureValue = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, ScreenUV, 0);
		float3 BentNormalAO = TextureValue.xyz;
		float BentNormalLength = length(BentNormalAO);

#define USE_CONE_TRACED_SPECULAR_OCCLUSION 0
#if USE_CONE_TRACED_SPECULAR_OCCLUSION
		IndirectSpecularOcclusion = TextureValue.w;
#else
		BRANCH
		if (bTwoSidedFoliage)
		{
			IndirectSpecularOcclusion = BentNormalLength;
		}
		else
		{
			float ReflectionConeAngle = Roughness * PI;
			float UnoccludedAngle = BentNormalLength * PI * InvSkySpecularOcclusionStrength;
			float AngleBetween = acos(dot(BentNormalAO, ReflectionVector) / max(BentNormalLength, .001f));
			IndirectSpecularOcclusion = ApproximateConeConeIntersection(ReflectionConeAngle, UnoccludedAngle, AngleBetween);

			// Can't rely on the direction of the bent normal when close to fully occluded, lerp to shadowed
			IndirectSpecularOcclusion = lerp(0, IndirectSpecularOcclusion, saturate((UnoccludedAngle - .1f) / .2f));
			IndirectSpecularOcclusion = lerp(IndirectSpecularOcclusion, 1, MinSkySpecularOcclusion);
		}
#endif

		IndirectDiffuseOcclusion = lerp(BentNormalLength, 1, MinSkySpecularOcclusion);
	}
}

float GetDynamicSkyIndirectIrradiance(float2 ScreenUV, float3 WorldNormal)
{
	float3 BentNormal = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, ScreenUV, 0).xyz;
	float SkyVisibility = length(BentNormal);
	float3 DiffuseLookup = GetSkySHDiffuse(WorldNormal) * Frame.SkyLightColor.rgb;
	return Luminance(DiffuseLookup) * SkyVisibility;
}