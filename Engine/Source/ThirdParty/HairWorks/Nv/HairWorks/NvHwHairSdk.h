// This code contains NVIDIA Confidential Information and is disclosed 
// under the Mutual Non-Disclosure Agreement. 
// 
// Notice 
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES 
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO 
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT, 
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. 
// 
// NVIDIA Corporation assumes no responsibility for the consequences of use of such 
// information or for any infringement of patents or other rights of third parties that may 
// result from its use. No license is granted by implication or otherwise under any patent 
// or patent rights of NVIDIA Corporation. No third party distribution is allowed unless 
// expressly authorized by NVIDIA.  Details are subject to change without notice. 
// This code supersedes and replaces all information previously supplied. 
// NVIDIA Corporation products are not authorized for use as critical 
// components in life support devices or systems without express written approval of 
// NVIDIA Corporation. 
// 
// Copyright (c) 2013-2015 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and proprietary
// rights in and to this software and related documentation and any modifications thereto.
// Any use, reproduction, disclosure or distribution of this software and related
// documentation without an express license agreement from NVIDIA Corporation is
// strictly prohibited.
//

/*

-----------------------------------------------------------------------------
                                   HairWorks                                 
-----------------------------------------------------------------------------

NVIDIA HairWorks enables users to simulate and render fur/hair to provide a 
truly interactive game experience. The technology originates from multiple 
simulation and rendering technologies that NVIDIA has developed in the past. 
This combines rendering technologies for human hair (GDC 2008) as well as 
various simulation technologies shown in multiple events (Fur Demo - GDC2012).

To make the hair/fur technologies a product, NVIDIA engineers have put
together these existing technologies and added new techniques to ensure a 
smooth pipeline for a variety of characters.

-----------------------------------------------------------------------------
                             INTEGRATION EXAMPLE                             
-----------------------------------------------------------------------------

This is an overview of the integration. Please refer to the API documentation
in the header file and the sample code for details.

(1.) LOAD THE LIBRARY

	// Allows wrapping of Dx11 types so they can be passed in and out of the sdk
	#include <Nv/Platform/Dx11/Foundation/NvDx11Handle.h>
	// HairWorks main header file
	#include <Nv/HairWorks/NvHwHairSdk.h> 
	// Optional header that allows easy loading of the dll 
	#include <Nv/Platform/Win/HairWorks/NvHwWinLoadSdk.h>

	NvHw::HairSdk* hairSdk = NvHw::loadHairSdk("NvHairWorksDx11.win64.dll", NV_HW_VERSION);

(2.) INITIALIZE

Initialize D3D Device.

	hairSdk->initRenderResources(Nv::Dx11Type::getHandle(d3dDevice));

Create the hair asset manually from your asset data

	NvHw::HairAssetDescriptor hairAssetDescriptor;
	hairAssetDescriptor.m_numGuideHairs = 4;
	hairAssetDescriptor.m_numVertices = 20;
	hairAssetDescriptor.m_vertices = vertices;
	hairAssetDescriptor.m_endIndices = endIndices;
	hairAssetDescriptor.m_bindPoses = bindPoses;
	hairAssetDescriptor.m_boneParents = boneParents;
	...
	hairSdk->createHairAsset(hairAssetDescriptor, &hairAssetId);

Or load it from the .apx file (generated by DCC tool or FurViewer) using the API.
	
	hairSdk->loadHairAssetFromFile("test.apx", &hairAssetId);

Create a hair instance from the hair asset.

	hairSdk->createHairInstance(hairAssetId, &hairInstanceId);

(3.) SIMULATION/RENDERING

Set render context for HairWorks.

	hairSdk->setCurrentContext(Nv::Dx11Type::getHandle(d3dContext));

Update descriptor parameters for each hair instance.

	HairInstanceDescriptor hairInstanceDescriptor;
	hairInstanceDescriptor.m_width = 0.2;
	hairInstanceDescriptor.m_density = 1.0;
	hairInstanceDescriptor.m_lengthNoise = 0.0f;
	hairInstanceDescriptor.m_simulate = true;
	...
	hairSdk->updateInstanceDescriptor(hairInstanceId, hairInstanceDescriptor);

Update skinning matrices for each hair
	hairSdk->updateSkinningMatrices(hairInstanceId, numBones, natrices); 

Run simulation for all hairs.

	hairSdk->stepSimulation(elapsedTime);

Set view matrix and projection matrix.

	D3DXMATRIX projection = camera.GetProjectionMatrix();
	D3DXMATRIX view = camera.GetViewMatrix();
	hairSdk->setViewProjection((const gfsdk_float4x4*)&view,(const gfsdk_float4x4*)&projection);

Set your hair pixel shader before rendering hairs.

	pd3dContext->PSSetShader(g_customHairWorksShader, NV_NULL, 0);

Render each hair instance.

	hairSdk->renderHairs(hairInstanceId);

(4.) RELEASE

	hairSdk->freeHairInstance(hairInstanceId);
	hairSdk->freeHairAsset(hairAssetId);
	hairSdk->freeRenderResources();
	hairSdk->release();
*/

#ifndef NV_HW_HAIR_SDK_H
#define NV_HW_HAIR_SDK_H

#include "NvHwCommon.h"
#include <Nv/Foundation/NvResult.h>

#include <Nv/Foundation/NvMemoryAllocator.h>
#include <Nv/Foundation/NvTypeMacros.h>
#include <Nv/Foundation/NvLogger.h>
#include <Nv/Foundation/NvStream.h>

#include <Nv/Foundation/NvApiHandle.h>

namespace Nv {
namespace HairWorks {

#define NV_HW_VERSION 112				// internal version number to match runtime DLLs. 
#define NV_HW_VERSION_STRING "1.1.2"	// version string for .apx file format

/*! \brief Identifier for hair asset data.
	\details The asset id is assigned by HairWorks SDK, and corresponds to a unique asset type.
	\see HairSdk.loadHairAsset() */
enum HairAssetId
{
	HAIR_ASSET_ID_NULL = 0xFFFF	//!< invalid hair asset ID
};

/*! \brief Identifier for a hair instance
	\details Multiple hair instances can be created from a single asset type.  
	\see HairSdk.createHairInstance() and HairSdk.freeHairInstance() */
enum HairInstanceId
{
	HAIR_INSTANCE_ID_NULL = 0xFFFF //!< invalid hair instance ID
};

/*! Error code for all HairSdk functions. Any changes in this list
should be reflected in changes to NV_HW_RESULT_OK and NV_HW_RESULT_FAIL x macros */
class SubResult { SubResult(); public: enum Enum
{ 
	OK,						//!< succeeded
	FAIL,					//!< unknown failure
	OPEN_FAILED,			//!< file or stream open(or write) failed
	INVALID_PARAMETERS,		//!< invalid options to the method
	INVALID_FORMAT,			//!< invalid file or memory format
	VERSION_MISMATCH,		//!< not supported version
}; };
typedef SubResult::Enum ESubResult;

#define NV_HW_RESULT_OK(x) x(OK)
#define NV_HW_RESULT_FAIL(x) x(FAIL) x(OPEN_FAILED) x(INVALID_PARAMETERS) x(INVALID_FORMAT) x(VERSION_MISMATCH)

// The facility associated with this type
#define NV_FACILITY_HAIR_WORKS	(NV_FACILITY_BASE + 1)

#define NV_HW_EXPAND_OK(x) RESULT_##x = NV_MAKE_RESULT(NV_SEVERITY_SUCCESS, NV_FACILITY_HAIR_WORKS, SubResult::x),
#define NV_HW_EXPAND_FAIL(x) RESULT_##x = NV_MAKE_RESULT(NV_SEVERITY_ERROR, NV_FACILITY_HAIR_WORKS, SubResult::x),

/*! All of the results for this facility. Can cast a result to NvHw::FacilityResult to quickly see the result */
enum FacilityResult
{
	NV_HW_RESULT_OK(NV_HW_EXPAND_OK)
	NV_HW_RESULT_FAIL(NV_HW_EXPAND_FAIL)
};

#define NV_HW_RESULT(x) ::NvResult(::NvHw::RESULT_##x)

/*! A method that converts an arbitrary Result, as returned from many methods in the API into a SubResult. Any success will be 
returned as SubResult::OK, any unknown failure as SubResult::FAIL */
NV_FORCE_INLINE ESubResult getSubResult(Result res)
{
	if (NV_SUCCEEDED(res)) 
	{
		return SubResult::OK;
	}
	return (NV_GET_RESULT_FACILITY(res) == NV_FACILITY_HAIR_WORKS) ? ESubResult(NV_GET_RESULT_CODE(res)) : SubResult::FAIL;
}

///maximum allowed size for name string
#define NV_HW_MAX_STRING 128 

/*! \brief Coordinate system setting for file import and camera view projection
\details Handedness of coordinate system may affect internal HairWorks computation dependent on camera such as culling and shading */
class HandednessHint { HandednessHint();  public: enum Enum
{
	UNKNOWN,	//!< don't know the handedness, use best guess.
	RIGHT,		//!< uses a right handed system (Z is pointing toward the viewer)
	LEFT,		//!< uses a left handed system ( Z is pointing away from the viewer)
	COUNT_OF,
}; };
typedef HandednessHint::Enum EHandednessHint;

/*! \brief Up axis setting of the asset
\details When up axis is different between original DCC tool and HairWorks runtime, provide this info to the file loading APIs.
\see HairImportSettings */
class AxisHint { AxisHint(); public: enum Enum
{
	UNKNOWN,	//!< don't know the up axis, use best guess.
	Y_UP,		//!< camera is y-up
	Z_UP,		//!< camera is z-up
	COUNT_OF,
}; };
typedef AxisHint::Enum EAxisHint;

/*! \brief HairWorks file header
	\details Contains info about this file.
	\note If the version is matched, HairSdk.loadHairAsset() fails. */
struct HairWorksInfo
{
	NV_DECLARE_CLASS_BASE(HairWorksInfo);

	enum { MAX_STRING_LENGTH = 1024 };

	Char m_fileVersion[MAX_STRING_LENGTH];	//!< file format version
	Char m_toolVersion[MAX_STRING_LENGTH];	//!< tool version
	Char m_sourcePath[MAX_STRING_LENGTH];	//!< source asset path
	Char m_authorName[MAX_STRING_LENGTH];	//!< author name
	Char m_lastModified[MAX_STRING_LENGTH]; //!< last modified date and time in format "YYYY-MM-DD HH:MM:SS"

	HairWorksInfo()
	{
		m_fileVersion[0] = '\0';
		m_toolVersion[0] = '\0';
		m_sourcePath[0] = '\0';
		m_authorName[0] = '\0';
		m_lastModified[0] = '\0';
	}
};

/*! \brief Describes each collision sphere attached to a bone
	\details To enable collision handling between sphere and/or capsule and hair curves, we define a 'boneSphere',
		a sphere whose center is attached to one of the bones used for skinning hairs.
		One can assign radius as well as initial offset with regard to the bind pose of the attached bone. */
struct BoneSphere
{
	UInt32	m_boneSphereIndex;			//!< index for the bone where the collision sphere is attached to
	Float32	m_boneSphereRadius;			//!< radius for the collision sphere
	gfsdk_float3 m_boneSphereLocalPos;	//!< offset value with regard to bind position of the bone
};

/*! \brief Descriptor to control properties of pin
	\note for compatibility of older version of apx file, the names of three properties corresponding with m_boneIndex,
	m_radius and m_localPos are still boneSphereIndex, boneSphereRadius, boneSphereLocalPos in new version of apx file.*/
struct Pin
{
	UInt32			m_boneIndex;				//!< index for the bone where the pin is attached to
	Float32			m_radius;					//!< radius of the sphere the pin influence on
	gfsdk_float3	m_localPos;					//!< offset value with regard to bind position of the bone
	Float32			m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	Float32			m_influenceFallOff;			//!< [0 - 1.0] how soft/hard the fall off of the hair pin zone of influence is
	Bool			m_useDynamicPin;			//! [true/false] whether to turn on/off dynamic pin
	Bool			m_useStiffnessPin;			//! [true/false] whether to turn on/off global stiffness on pin
	Bool			m_doLra;					//! [true/false] whether to turn on/off LRA pin
	Bool			m_selected;					//! [true/false] whether this pin is selected

	gfsdk_float4	m_influenceFallOffCurve;	//! [0 - 1.0] curve values for influence fall off

	Pin() :
		m_boneIndex(0),
		m_radius(0),
		m_pinStiffness(1.0f),
		m_influenceFallOff(1.0f),
		m_useDynamicPin(false),
		m_useStiffnessPin(true),
		m_doLra(false),
		m_selected(false)
	{
		m_localPos.x = 0.0;
		m_localPos.y = 0.0;
		m_localPos.z = 0.0;

		m_influenceFallOffCurve.x = 1.0;
		m_influenceFallOffCurve.y = 1.0;
		m_influenceFallOffCurve.z = 1.0;
		m_influenceFallOffCurve.w = 1.0;
	}
};

/*!\brief Descriptor to specify hair asset (hair curves, growth mesh, skinning weights, bone info...)

	\details Hair assets are defined in memory with this data structure, and comprises important part of the hair asset data (.apx) file format.
	This structure defines a minimal static data needed to create hairs in HairWorks.
	A minimal hair assets consists of guide curve data typically exported from DCC tools, and growth mesh face index/uv data.
	Note that vertices of the growth mesh are required to match the root positions of hair guide curves, 
	so it is automatically derived from the curve data without being explicitly stored in the data structure.
	The skinning information (bone index, weight) is derived from that of the growth mesh, and we use skinning info
	to compute target (skinned) positions for each guide hair.  Same bone index/weights are used for CVs of each guide hair.

	\note When the data is invalid, NvHw::HairSdk.loadHairAsset() rejects the hair asset.
	\see All dynamic parameters per hair instance are defined in HairInstanceDescriptor. 
	\note for compatibility of older version of apx file, the names of two properties corresponding with m_numPins
	and m_pins are still numPinConstraints, pinConstraints in new version of apx file.*/
struct HairAssetDescriptor
{
	NV_DECLARE_CLASS_BASE(HairAssetDescriptor);

	Int32			m_numGuideHairs;//!< number of hair guide hair curves
	Int32			m_numVertices;	//!< total # of cv(control vertices) in guide curves
	gfsdk_float3*	m_vertices;		//!< all the cv positions of guide curves
	UInt32*			m_endIndices;	//!< index of last vertex for each hair curve pointing to the m_vertices array
									//!< size of this array should be 'm_numGuideHairs'	

	Int32			m_numFaces;		//!< number of hair triangles, we grow hairs for each mesh triangles
	UInt32*			m_faceIndices;	//!< triangle indices for hair faces, size must be 3 * m_numFaces
	gfsdk_float2*	m_faceUvs;		//!< uv values for hair faces, size must be 3 * m_numFaces

	Int32			m_numBones;		//!< number of bones used to skin hair curves
	gfsdk_float4*	m_boneIndices;	//!< size should be 'm_numGuideHairs'. each mesh vertex (hair root) can have up to 4 bone indices.
	gfsdk_float4*	m_boneWeights;	//!< size should be 'm_numGuideHairs'. each mesh vertex (hair root) can have up to 4 bone weights.

	Char*			m_boneNames;	//!<[OPTIONAL] names for each bone used to check if bone names match. buffer size should be at least NV_HW_MAX_STRING * 'm_numBones'.
	gfsdk_float4x4*	m_bindPoses;	//!<[OPTIONAL] bind pose matrices for each bone. buffer size should be at least sizeof(gfsdk_float4x4) * m_numBones.
	Int32*			m_boneParents;	//!<[OPTIONAL] parent index for each bone.  if this is a root bone, the index will be -1. buffer size should be at least sizeof(Nv::Int32) * m_numBones.

	Int32			m_numBoneSpheres;//!< [OPTIONAL] collision spheres used for collision handling between body and hair 
	BoneSphere*		m_boneSpheres;	//!< [OPTIONAL] collision sphere data, each sphere is attached to a bone. The size of this array should be m_numBoneSpheres.
	Int32			m_numBoneCapsules; //!< [OPTIONAL] capsules are defined by connecting a pair of collision spheres
	UInt32*			m_boneCapsuleIndices; //!< [OPTIONAL] index to the bone spheres, size of this array must be 2 * m_numBoneCapsules;

	UInt32			m_numPins;		//!< [OPTIONAL] spheres used to apply soft constraint to pin hairs around the spheres.
	Pin*			m_pins;			//!< [OPTIONAL] constraint sphere data, each sphere is attached to a bone. The size of this array should be m_numPins.

	Char*			m_textureNames;	//!< [OPTIONAL] placeholder to load hair texture file names from apx file. The size must be NV_HW_MAX_STRING * NvHw::HairTextureType::COUNT_OF

	Float32			m_sceneUnit;	//!< scene unit scale in centimeters used in the tool that generated this asset. Centimeter (default): 1.0, Meter: 100.0, Inch: 2.54, Decimeter: 10.0

	EHandednessHint m_handedness; //!< handedness of coordinate system this asset used at time of creation/conversion.  See HandednessHint.
	EAxisHint		m_upAxis;		//!< up axis of coordinate system this asset used at time of creation/conversion.  See AxisHint.
	
	HairAssetDescriptor::HairAssetDescriptor() :
		m_numGuideHairs(0),
		m_numVertices(0),		
		m_vertices(NV_NULL),
		m_endIndices(NV_NULL),

		m_numFaces(0),
		m_faceIndices(NV_NULL),
		m_faceUvs(NV_NULL),

		m_numBones(0),
		m_boneIndices(NV_NULL),
		m_boneWeights(NV_NULL),
		m_boneNames(NV_NULL),
		m_bindPoses(NV_NULL),
		m_boneParents(NV_NULL),

		m_numBoneSpheres(0),
		m_boneSpheres(NV_NULL),
		m_numBoneCapsules(0),
		m_boneCapsuleIndices(NV_NULL),

		m_numPins(0),
		m_pins(NV_NULL),

		m_textureNames(NV_NULL),

		m_sceneUnit(1.0f),
	
		m_handedness(HandednessHint::UNKNOWN),
		m_upAxis(AxisHint::UNKNOWN)
	{
	}
};

/*! \brief copy settings for asset import */
struct AssetCopySettings
{
	NV_DECLARE_CLASS_BASE(AssetCopySettings);

	Bool m_copyGroom;
	Bool m_copyCollision;
	Bool m_copyTextures;
	Bool m_copyConstraints;
	Bool m_copyAll;

	AssetCopySettings():
		m_copyAll(true),
		m_copyGroom(true),
		m_copyCollision(true),
		m_copyTextures(true),
		m_copyConstraints(true)
	{
	}
};

/*! \brief Texture types used for hair control textures
\details Some parameters for hair shape/shading/simulation can be controlled with more detail by textures.
Most of these textures are sampled based on (U,V) values derived from the growth mesh.
It is OK to share same texture resource for multiple texture type.
Most of textures have a corresponding constant value, and its value gets used as a multiplier to sampled texture values.
\see HairSdk.setTexture() */
class HairTextureType { HairTextureType(); public: enum Enum
{
	DENSITY,		//<! hair density map [ shape control ]
	ROOT_COLOR,		//<! color at the hair root [ shading ]
	TIP_COLOR,		//<! color at the hair tip [ shading ]
	WIDTH,			//<! width  [ shape control ]
	STIFFNESS,		//<! stiffness control [ simulation ]
	ROOT_STIFFNESS, //<! stiffness control for root stiffness [simulation]
	CLUMP_SCALE,	//<! clumpiness control [ shape control]
	CLUMP_ROUNDNESS,//<! clumping noise [ shape control]
	WAVE_SCALE,		//<! waviness scale [ shape control ]
	WAVE_FREQ,		//<! waviness frequency [ shape control ]
	STRAND,			//<! texture along hair strand [ shading ]
	LENGTH,			//<! length control [shape control] 
	SPECULAR,		//<! specularity control [shading ] 
	WEIGHTS,		//!< weight texture for multiple material blending [control for all other textures]
	COUNT_OF,
}; };
typedef HairTextureType::Enum EHairTextureType;

/*! \brief Texture channel for each control textures
\details For a single-channel control textures, one can pack multiple control textures into a single texture resource.
When such packing is used, assign channel for each control texture type. */
class TextureChannel { TextureChannel(); public: enum Enum
{
	RED,
	GREEN,
	BLUE,
	ALPHA
}; };
typedef TextureChannel::Enum ETextureChannel;

class ShaderResourceType { ShaderResourceType(); public: enum Enum 
{
	HAIR_INDICES,			//!< face to hair index buffer
	TANGENTS,				//!< hair tangent buffer for master strands
	NORMALS,				//!< hair normal buffer for master strands
	MASTER_POSITIONS,		//!< position for master strand
	PREV_MASTER_POSITIONS,	//!< previous position for master strands
	COUNT_OF,
}; };
typedef ShaderResourceType::Enum EShaderResourceType;

/*! \brief Blend mode for strand texture.
\details When the strand texture is used, the blend mode determines how colors should combine between the strand texture and other color textures (root, tip, etc.) */
class StrandBlendMode { StrandBlendMode(); public: enum Enum
{
	OVERWRITE,	//!< overwrite with strand texture
	MULTIPLY,	//!< multiply strand texture to base color (root/tip)
	ADD,		//!< add strand color on top of base color
	MODULATE,	//!< add/subtract strand color to/from base color
	COUNT_OF
}; };
typedef StrandBlendMode::Enum EStrandBlendMode;

/*! \brief Colorize option for hair
\details Different options for colorizing hairs for visualization. */
class ColorizeMode { ColorizeMode(); public: enum Enum 
{
	NONE,
	LOD,		//!< colorize lod factors
	TANGENTS,	//!< colorize hair tangents
	NORMAL,		//!< colorize hair growth mesh normal
	RED,		//!< just constant red color for debugging
	COUNT_OF,
}; };
typedef ColorizeMode::Enum EColorizeMode;

/*! \brief Specifies the available serialization formats */
class SerializeFormat { SerializeFormat(); public: enum Enum
{
	UNKNOWN,		//< Format could not be determined
	XML,			//< XML text/human readable format
	BINARY,			//< Binary format
	COUNT_OF,
}; };
typedef SerializeFormat::Enum ESerializeFormat;

/*! \brief Teleport mode
\details Options for teleport control in UpdateSkinningMatrices. */
class TeleportMode { TeleportMode(); public: enum Enum
{
	NONE,					//!< no teleport (keep simulating)
	WITH_SKINNED_POSITION,	//!< teleport and set simulation state to skinned position
	COUNT_OF,
}; };
typedef TeleportMode::Enum ETeleportMode;

/*! \brief Descriptor to control all aspects of hair (can be updated and animated per fame)
	\details HairWorks provides a unified parameter control for shape, simulation and rendering through HairInstanceDescriptor.
		These parameters can be updated using HairSdk.updateInstanceDescriptor() between function calls to render or simulations.
	\note Some parameters are length/scale dependent, and all our default values are optimized for CENTIMETERS.
		If the hair scene uses different unit, all unit dependent parameters can be automatically scaled when HairInstanceDescriptor.m_unitInCentimeters is set correspondingly. */
struct HairInstanceDescriptor
{
	NV_DECLARE_CLASS_BASE(HairInstanceDescriptor);

	// global controls
	Bool		m_enable;					//!< [true/false] whether to enable this hair. When disabled, hair will not cause any computation/rendering

	// hair geometry (density/width/length/clump) controls
	Float32		m_width;					//!< [In Millimeters] hair width (thickness)
	Float32		m_widthNoise;				//!< [0 - 1.0] noise factor for hair width noise 
	Float32		m_widthRootScale;			//!< [0 - 1.0] scale factor for top side of the strand
	Float32		m_widthTipScale;			//!< [0 - 1.0] scale factor for bottom side of the strand

	Float32		m_clumpNoise;				//!< [0 - 1.0] probability of each hair gets clumped (0 = all hairs get clumped, 1 = clump scale is randomly distributed from 0 to 1)
	Float32		m_clumpRoundness;			//!< [0 - 2.0] exponential factor to control roundness of clump shape (0 = linear cone, clump scale *= power(t, roundness), where t is normalized distance from the root)
	Float32		m_clumpScale;				//!< [0 - 1.0] how clumped each hair face is

	Float32		m_density;					//!< [0 -    ] hair density per face (1.0 = 64 hairs per face)
	Bool		m_usePixelDensity;			//!< [true/false] whether to use per-pixel sampling or per-vertex sampling for density map

	Float32		m_lengthNoise;				//!< [0 - 1.0] length variation noise
	Float32		m_lengthScale;				//!< [0 - 1.0] length control for growing hair effect

	Float32		m_waveScale;				//!< [In Centimeters] size of waves for hair waviness 
	Float32		m_waveScaleNoise;			//!< [0 - 1.0] noise factor for the wave scale
	Float32		m_waveScaleClump;			//!< [0 - 1.0] waviness at clump level
	Float32		m_waveScaleStrand;			//!< [0 - 1.0] waviness at strand level
	Float32		m_waveFreq;					//!< [0 -    ] wave frequency (1.0 = one sine wave along hair length)
	Float32		m_waveFreqNoise;			//!< [0 - 1.0] noise factor for the wave frequency 
	Float32		m_waveRootStraighten;		//!< [0 - 1.0] For some distance from the root, we attenuate waviness so that root itself does not move [0-1]

	/// shading controls
	Float32		m_rootAlphaFalloff;			//!< [0 - 1.0] falloff factor for alpha transition from root 
	gfsdk_float4 m_rootColor;				//!< [0 - 1.0] color of hair root (when hair textures are not used)
	gfsdk_float4 m_tipColor;				//!< [0 - 1.0] color of hair tip (when hair textures are not used)
	Float32		m_rootTipColorWeight;		//!< [0 - 1.0] blend factor between root and tip color in addition to hair length
	Float32		m_rootTipColorFalloff;		//!< [0 - 1.0] falloff factor for root/tip color interpolation

	Float32		m_diffuseBlend;				//!< [0 - 1.0] blend factor between Kajiya hair lighting vs normal skin lighting.
	Float32		m_hairNormalWeight;			//!< [0 - 1.0] blend factor between mesh normal vs hair normal. Use higher value for longer (surface like) hair.
	UInt32		m_hairNormalBoneIndex;		//!< [0 - number of bones] index for the bone which we use as model center for diffuse shading purpose

	gfsdk_float4 m_specularColor;			//!< [0 - 1.0] specular color
	Float32		m_specularNoiseScale;		//!< [0 - 1.0] amount of specular noise
	Float32		m_specularEnvScale;			//!< [0 - 1.0] amount of specular scale from env probe
	Float32		m_specularPrimary;			//!< [0 - 1.0] primary specular factor
	Float32		m_specularPowerPrimary;		//!< [0 - ] primary specular power exponent
	Float32		m_specularPrimaryBreakup;	//!< [0 - 1.0] shift factor to make specular highlight move with noise
	Float32		m_specularSecondary;		//!< [0 - 1.0] secondary specular factor
	Float32		m_specularSecondaryOffset;	//!< [0 - 1.0] secondary highlight shift offset along tangents
	Float32		m_specularPowerSecondary;	//!< [0 - ] secondary specular power exponent		

	Float32		m_glintStrength;			//!< [0 - 1.0] strength of the glint noise
	Float32		m_glintCount;				//!< [0 - 1024] number of glint sparklers along each hair
	Float32		m_glintExponent;			//!< [0 - ] glint power exponent

	Bool		m_castShadows;				//!< [true/false] this hair cast shadows onto the scene
	Bool		m_receiveShadows;			//!< [true/false] this hair receives shadows from the scene
	Float32		m_shadowSigma;				//!< [In Centimeters] distance through hair volume beyond which hairs get completely shadowed.

	UInt32		m_strandBlendMode;			//!< [EStrandBlendMode] blend mode when strand texture is used. Supported mode are defined in EStrandBlendMode
	Float32		m_strandBlendScale;			//!< [0 - 1.0] scale strand texture before blend

	// simulation control
	Float32		m_backStopRadius;			//!< [0 - 1.0] radius of backstop collision (normalized along hair length)
	Float32		m_bendStiffness;			//!< [0 - 1.0] stiffness for bending, useful for long hair
	Float32		m_damping;					//!< [0 - ] damping to slow down hair motion
	gfsdk_float3 m_gravityDir;				//!< [0 - 1.0] gravity force direction (unit vector)
	Float32		m_friction;					//!< [0 - 1.0] friction when capsule collision is used
	Float32		m_massScale;				//!< [In Meters] mass scale for this hair
	Float32		m_inertiaScale;				//!< [0 - 1.0] inertia control. (0: no inertia, 1: full inertia)
	Float32		m_inertiaLimit;				//!< [In Meters] speed limit where everything gets locked (for teleport etc.)
	Float32		m_interactionStiffness;		//!< [0 - 1.0] how strong the hair interaction force is
	Float32		m_rootStiffness;			//!< [0 - 1.0] attenuation of stiffness away from the root (stiffer at root, weaker toward tip)
	Float32		m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	Bool		m_simulate;					//!< [true/false] whether to turn on/off simulation
	Float32		m_stiffness;				//!< [0 - 1.0] how close hairs try to stay within skinned position
	Float32		m_stiffnessStrength;		//!< [0 - 1.0] how strongly hairs move toward the stiffness target
	Float32		m_stiffnessDamping;			//!< [0 - 1.0] how fast hair stiffness generated motion decays over time
	Float32		m_tipStiffness;				//!< [0 - 1.0] attenuation of stiffness away from the tip (stiffer at tip, weaker toward root)
	Bool		m_useCollision;				//!< [true/false] whether to use the sphere/capsule collision or not for hair/body collision
	gfsdk_float3 m_wind;					//!< [In Meters] vector force for main wind direction
	Float32		m_windNoise;				//!< [0 - 1.0] strength of wind noise

	gfsdk_float4	m_stiffnessCurve;			//! [0 - 1.0] curve values for stiffness 
	gfsdk_float4	m_stiffnessStrengthCurve;	//! [0 - 1.0] curve values for stiffness strength
	gfsdk_float4	m_stiffnessDampingCurve;	//! [0 - 1.0] curve values for stiffness damping
	gfsdk_float4	m_bendStiffnessCurve;		//! [0 - 1.0] curve values for bend stiffness
	gfsdk_float4	m_interactionStiffnessCurve;//! [0 - 1.0] curve values for interaction stiffness
	Bool			m_useDynamicPin;			//! [true/false] whether to turn on/off dynamic pin

	// lod controls
	Bool		m_enableLod;				//!< [true/false] whether to enable/disable entire lod scheme

	Bool		m_enableDistanceLod;		//!< [true/false] whether to enable lod for far away object (distance LOD)
	Float32		m_distanceLodStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start fading out (by reducing density)
	Float32		m_distanceLodEnd;			//!< [In Meters] distance (in scene unit) to camera where fur will completely disappear (and stop simulating)
	Float32		m_distanceLodFadeStart;		//!< [In Meters] distance (in scene unit) to camera where fur will fade with alpha from 1 (this distance) to 0 (DistanceLODEnd)
	Float32		m_distanceLodDensity;		//!< [0 - ] density when distance LOD is in action.  hairDensity gets scaled based on LOD factor.
	Float32		m_distanceLodWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	Bool		m_enableDetailLod;			//!< [true/false] whether to enable lod for close object (detail LOD)
	Float32		m_detailLodStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start getting denser toward closeup density
	Float32		m_detailLodEnd;				//!< [In Meters] distance (in scene unit) to camera where fur will get full closeup density value
	Float32		m_detailLodDensity;			//!< [0 - ] density scale when closeup LOD is in action.  hairDensity gets scaled based on LOD factor.
	Float32		m_detailLodWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	Float32		m_shadowDensityScale;		//!< [0 - 1] density scale factor to reduce hair density for shadow map rendering

	Bool		m_useViewfrustrumCulling;	//!< [true/false] when this is on, density for hairs outside view are set to 0. Use this option when fur is in a closeup.
	Bool		m_useBackfaceCulling;		//!< [true/false] when this is on, density for hairs growing from backfacing faces will be set to 0
	Float32		m_backfaceCullingThreshold; //!< [-1 - 1.0] threshold to determine backface, note that this value should be slightly smaller 0 to avoid hairs at the silhouette from disappearing

	Bool		m_useCullSphere;			//!< [true/false] when this is on, hairs get culled when their root points are inside the sphere
	gfsdk_float4x4 m_cullSphereInvTransform;	//!< inverse of general affine transform (scale, rotation, translation..) applied to a unit sphere centered at origin

	UInt32		m_splineMultiplier;			//!< how many vertices are generated per each control hair segments in spline curves

	// asset grouping
	UInt32		m_assetType;				//!< This value can be used to classify different types of hair in a game. (e.g. 0 = fur, 1 = hair, 2 = very long hair, etc.)
	UInt32		m_assetPriority;			//!< This value can be used to sort assets via importance in a game.
	UInt32		m_assetGroup;				//!< This can be used to cluster a set of assets to character grouping.

	// drawing option
	Bool		m_drawRenderHairs;			//!< [true/false] draw render hair
	Bool		m_visualizeBones;			//!< [true/false] visualize skinning bones
	Bool		m_visualizeBoundingBox;		//!< [true/false] draw bounding box of hairs
	Bool		m_visualizeCapsules;		//!< [true/false] visualize collision capsules
	Bool		m_visualizeControlVertices; //!< [true/false] draw control vertices of guide hairs
	Bool		m_visualizeCullSphere;		//!< [true/false] draw cull sphere
	Bool		m_visualizeFrames;			//!< [true/false] visualize coordinate frames
	Bool		m_visualizeGrowthMesh;		//!< [true/false] draw growth mesh
	Bool		m_visualizeGuideHairs;		//!< [true/false] draw guide hairs
	Bool		m_visualizeHairInteractions;//!< [true/false] draw hair interaction lines
	UInt32		m_visualizeHairSkips;		//!< [0 - ] for per hair visualization, how many hairs to skip?
	Bool		m_visualizeLocalPos;		//!< [true/false] visualize target pose for bending
	Bool		m_visualizePinConstraints;	//!< [true/false] whether to visualize pin constraint spheres
	Bool		m_visualizeShadingNormals;	//!< [true/false] visualize normals used for hair shading
	Bool		m_visualizeShadingNormalBone; //!< [true/false] visualize bone used as shading normal center
	Bool		m_visualizeSkinnedGuideHairs; //!< [true/false] draw skinned positions for guide hairs

	UInt32		m_colorizeMode;				//!< [ColorizeMode] colorize hair based on various terms. See ColorizeMode.
	
	ETextureChannel m_textureChannels[HairTextureType::COUNT_OF]; //!< texture channel for each control textures.  
	
	gfsdk_float4x4	m_modelToWorld;			//!< render time transformation to offset hair from its simulated position

	// default values
	HairInstanceDescriptor() :
		m_enable(true),

		// default geometry parameters
		m_width(1.0f),
		m_widthNoise(0.0f),
		m_widthRootScale(1.0f),
		m_widthTipScale(0.1f),

		m_clumpNoise(0.0f),
		m_clumpRoundness(1.0f),
		m_clumpScale(0.0f),
		
		m_density(1.0f), 
		m_lengthNoise(1.0f),
		m_lengthScale(1.0f),
			
		m_usePixelDensity(false),
		m_waveScale(0.0f),
		m_waveScaleClump(0.0f),
		m_waveScaleStrand(1.0f),
		m_waveScaleNoise(0.5f),
		m_waveFreq(3.0f),
		m_waveFreqNoise(0.5f),
		m_waveRootStraighten(0.0f),

		// default shading parameters
		m_diffuseBlend(0.5f),
		m_hairNormalWeight(0.0f),
		m_hairNormalBoneIndex(UInt32(-1)),

		m_glintStrength(0.0f),
		m_glintCount(256.0f),
		m_glintExponent(2.0f),
		m_rootTipColorWeight(0.5f),
		m_rootTipColorFalloff(1.0f),

		m_specularNoiseScale(0.0f),
		m_specularEnvScale(0.25f),
		m_specularPrimary(0.1f),
		m_specularPrimaryBreakup(0.0f),
		m_specularSecondary(0.05f),
		m_specularSecondaryOffset(0.1f),
		m_specularPowerPrimary(100.0f),
		m_specularPowerSecondary(20.0f),

		m_rootAlphaFalloff(0.0f),

		m_shadowSigma(0.2f),
		m_castShadows(true),
		m_receiveShadows(true),

		m_strandBlendMode(UInt32(StrandBlendMode::OVERWRITE)),
		m_strandBlendScale(1.0f),

		// default simulation parameters
		m_simulate(true),
		m_backStopRadius(0.0f),
		m_bendStiffness(0.0f),
		m_damping(0.0f),
		m_friction(0.0f),
		m_inertiaScale(1.0f),
		m_inertiaLimit(1000.0f),
		m_interactionStiffness(0.0f),
		m_massScale(10.0f),
		m_windNoise(0.0f),
		m_stiffness(0.5f),
		m_stiffnessStrength(1.0f),
		m_stiffnessDamping(0.0f),
		m_rootStiffness(0.5f),
		m_pinStiffness(1.0f),
		m_tipStiffness(0.0f),
		m_useCollision(false),
		m_useDynamicPin(false),

		// default LOD parameters
		m_enableLod(false),

		m_enableDistanceLod(true),
		m_distanceLodStart(5.0f), 
		m_distanceLodEnd(10.0f), 
		m_distanceLodFadeStart(1000.0f),
		m_distanceLodDensity(0.0f),
		m_distanceLodWidth(1.0f),

		m_enableDetailLod(true),
		m_detailLodStart(2.0f), 
		m_detailLodEnd(1.0f), 
		m_detailLodDensity(1.0f),
		m_detailLodWidth(1.0f),

		m_shadowDensityScale(0.5f),

		m_useViewfrustrumCulling(true),
		m_useBackfaceCulling(false),
		m_backfaceCullingThreshold(-0.2f),
		m_useCullSphere(false),

		m_splineMultiplier(4),

		m_assetType(0),
		m_assetPriority(0),
		m_assetGroup(0),

		// visualization options
		m_drawRenderHairs(true),		
		m_visualizeBones(false),
		m_visualizePinConstraints(false),
		m_visualizeCapsules(false),
		m_visualizeGrowthMesh(false),	
		m_visualizeGuideHairs(false),	
		m_visualizeControlVertices(false),
		m_visualizeBoundingBox(false),
		m_visualizeCullSphere(false),
		m_visualizeShadingNormalBone(false),
		m_visualizeHairInteractions(false),
		m_visualizeSkinnedGuideHairs(false),	
		m_visualizeFrames(false),
		m_visualizeLocalPos(false),
		m_visualizeShadingNormals(false),
		m_visualizeHairSkips(0),

		m_colorizeMode(UInt32(ColorizeMode::NONE))

		{
			m_gravityDir.x = 0.0f; 
			m_gravityDir.y = 0.0f; 
			m_gravityDir.z = -1.0f;

			m_wind.x = 0.0f; 
			m_wind.y = 0.0f; 
			m_wind.z = 0.0f;

			m_rootColor.x = 1.0f; m_rootColor.y = 1.0f; m_rootColor.z = 1.0f; m_rootColor.w = 1.0f;
			m_tipColor.x = 1.0f; m_tipColor.y = 1.0f; m_tipColor.z = 1.0f; m_tipColor.w = 1.0f;
			m_specularColor.x = 1.0f; m_specularColor.y = 1.0f; m_specularColor.z = 1.0f; m_specularColor.w = 1.0f;

#define NV_HW_MAKE_IDENTITY(M) M._11 = 1.0f; M._12 = 0.0f; M._13 = 0.0f; M._14 = 0.0f; \
			M._21 = 0.0f; M._22 = 1.0f; M._23 = 0.0f; M._24 = 0.0f; \
			M._31 = 0.0f; M._32 = 0.0f; M._33 = 1.0f; M._34 = 0.0f; \
			M._41 = 0.0f; M._42 = 0.0f; M._43 = 0.0f; M._44 = 1.0f;

			NV_HW_MAKE_IDENTITY(m_modelToWorld);

			NV_HW_MAKE_IDENTITY(m_cullSphereInvTransform);

#undef NV_HW_MAKE_IDENTITY

#define NV_HW_SETX(X, V) X.x = V; X.y = V; X.z = V; X.w = V;

			NV_HW_SETX(m_stiffnessCurve, 1.0f);
			NV_HW_SETX(m_stiffnessStrengthCurve, 1.0f);
			NV_HW_SETX(m_stiffnessDampingCurve, 1.0f);
			NV_HW_SETX(m_bendStiffnessCurve, 1.0f);
			NV_HW_SETX(m_interactionStiffnessCurve, 1.0f);
#undef NV_HW_SETX

			for (IndexT i = 0; i < IndexT(HairTextureType::COUNT_OF); i++)
				m_textureChannels[i] = TextureChannel::RED;
		}
};

/*! \brief statistics for optimization and profiling
	\details For statistics or profiling purpose, one can query the HairSdk how much resources are currently consumed.
	\see Use HairSdk.computeStats() to retrieve this data. */
struct HairStats
{
	NV_DECLARE_CLASS_BASE(HairStats);

	Int	m_numHairs;					//!< total hair counts for the hair instances
	Int	m_numFaces;					//!< total face counts for the hair instance
	Float m_averageNumCvsPerHair;	//!< average number of control vertices (CVs) per hair
	Float m_averageDensity;			//!< average density, accounting for density maps, etc.
	Float m_averageHairsPerFace;	//!< average hairs per face

	Float m_distanceLodFactor;		//!< distance LOD factor
	Float m_detailLodFactor;		//!< closeup LOD factor
	Float m_camDistance;			//!< distance to camera

	HairStats() :
		m_numHairs(0),
		m_numFaces(0),
		m_averageNumCvsPerHair(0.0f),
		m_averageDensity(0.0f),
		m_averageHairsPerFace(0.0f),
		m_distanceLodFactor(0.0f),
		m_detailLodFactor(0.0f),
		m_camDistance(0.0f)
	{}
};

/** \brief Data structure used to customize HairWorks shader settings.
	\details Users can customize HairWorks runtime by providing their render settings with this structure.
	\see HairSdk.renderHairs() */
struct ShaderSettings
{
	NV_DECLARE_CLASS_BASE(ShaderSettings);

	Bool	m_useCustomConstantBuffer;	//!< If true, HairWorks will not bind constant buffer
	Bool	m_shadowPass;				//!< If true, density and width will be adjusted based on m_shadowDensityScale of HairInstanceDescriptor

	ShaderSettings(Bool	useCustomConstantBuffer	= false, Bool shadowPass = false) 
	{
		m_useCustomConstantBuffer	= useCustomConstantBuffer;
		m_shadowPass				= shadowPass;
	}
};

/*! \brief shader cache settings to create optimized shader per each hair asset.
	\details By giving hints about which features are used, HairWorks can build optimized shader before runtime.
			 Note that once an option is disabled in shader cache, the feature will not work even if it is enabled in instance descriptor in runtime.
	\see HairSdk.addToShaderCache() to add optimized shader. */
struct ShaderCacheSettings
{
	NV_DECLARE_CLASS_BASE(ShaderCacheSettings);

	enum Flag
	{
		FLAG_CULL_SPHERE	= 0x01,	//!< if cull sphere is used (HairInstanceDescriptor.m_useCullSphere == true)
		FLAG_CLUMPING		= 0x02,	//!< if clumping is used (HairInstanceDescriptor.m_clumpScale > 0)
		FLAG_WAVE_STRAND	= 0x04,	//!< if strand waviness is used (HairInstanceDescriptor.m_waveScale > 0 && HairInstanceDescriptor.m_waveStrand > 0)
		FLAG_WAVE_CLUMP		= 0x08,	//!< if strand waviness is used (HairInstanceDescriptor.m_waveScale > 0 && HairInstanceDescriptor.m_waveClump > 0)
		FLAG_PIXEL_DENSITY	= 0x10,	//!< if per-pixel density option is used (HairInstanceDescriptor.m_usePixelDeisnty = true)
		FLAG_MAX_BIT		= 0x20,
	};

	Int32 m_useFlags;				///< Combination of Flag flags 
	Int32 m_textureUsedFlags;		///< Bit set for each of HairTextureType::COUNT_OF
	UInt32 m_channelPerTexture;		///< Each channel is held in 2 bits per HairTextureType::COUNT_OF

		/// True if used
	NV_FORCE_INLINE bool isUsed(Flag flag) const { return (m_useFlags & flag) != 0; }
		/// Set as used
	NV_FORCE_INLINE void setUsed(Flag flag, bool v) { m_useFlags = v ? (m_useFlags | flag) : (m_useFlags & ~flag); }

	NV_FORCE_INLINE bool isTextureUsed(Int i) const { NV_ASSERT(i >= 0 && i < Int(HairTextureType::COUNT_OF)); return (m_textureUsedFlags & (1 << i)) != 0; }
		/// Set the texture is used
	NV_FORCE_INLINE void setTextureUsed(Int i, bool v) { NV_ASSERT(i >= 0 && i < Int(HairTextureType::COUNT_OF));  m_textureUsedFlags = v ? (m_textureUsedFlags | (1 << i)) : (m_textureUsedFlags & (~(1 << i))); }

		/// Set the channel
	NV_FORCE_INLINE void setChannel(Int i, ETextureChannel chan)
	{
		const Int shift = i + i;
		m_channelPerTexture &= ~(UInt32(0x3) << shift);
		m_channelPerTexture |= (UInt32(chan) << shift);
	}
		/// Get the channel
	NV_FORCE_INLINE ETextureChannel getChannel(Int i) const { return ETextureChannel((m_channelPerTexture >> (i + i)) & 3); }
		/// Set everything to 0
	void zero() { m_useFlags = 0; m_textureUsedFlags = 0; m_channelPerTexture = 0; }

		// ==
	Bool operator==(const ThisType& rhs) const
	{
		return m_useFlags == rhs.m_useFlags &&
			m_textureUsedFlags == rhs.m_textureUsedFlags &&
			m_channelPerTexture == rhs.m_channelPerTexture;
	}
		// !=
	NV_FORCE_INLINE Bool operator!=(const ThisType& rhs) const { return !(*this == rhs); }

		/// Ctor. Default option is to turn on all the options
	ShaderCacheSettings()
	{
		m_useFlags = FLAG_MAX_BIT - 1;
		m_textureUsedFlags = (1 << Int(HairTextureType::COUNT_OF)) - 1;		// Set all textures on
		m_channelPerTexture = 0;											// Set all to 0 (RED)
	}

	// set feature sets from instance descriptor.
	// Note that texture references are not part of instance descriptor, so still need to be set after this function.
	Void setFromInstanceDescriptor(const HairInstanceDescriptor& desc)
	{
		setUsed(FLAG_PIXEL_DENSITY, desc.m_usePixelDensity);
		setUsed(FLAG_CULL_SPHERE, desc.m_useCullSphere);

		setUsed(FLAG_CLUMPING, desc.m_clumpScale > 0.0f);
		setUsed(FLAG_WAVE_STRAND, (desc.m_waveScale > 0.0f) && (desc.m_waveScaleStrand > 0.0f));
		setUsed(FLAG_WAVE_CLUMP, (desc.m_waveScale > 0.0f) && (desc.m_waveScaleClump > 0.0f));

		for (Int i = 0; i < Int(HairTextureType::COUNT_OF); i++)
			setChannel(i, desc.m_textureChannels[i]); //!< texture channel for each control textures.  
	}
};

/*!\brief Constant buffer structure to map hair shading data to DX constant buffer
	\see Use HairSdk.prepareShaderConstantBuffer() to get this data structure properly mapped for shader use. */
struct ShaderConstantBuffer
{
	enum 
	{
		BUFFER_SIZE = 512 // = 256 + 256 constant buffer size used by HairWorks pixel shader.
	};
	Float32 m_data[BUFFER_SIZE]; 
};

/*!\brief Settings to apply coordinate/unit conversion for hair asset loading.
	\details When hair asset is exported from various DCC tools, needs may arise to properly convert unit and coordinate system settings to match
		different setups in game engines. Use the following data structure to provide information about how HairWorks should convert those.
	\note The axis conversion uses data stored in HairAssetDescriptor (m_upAxis, m_handedness).
		If any of the data is set to unknown (0), or if any of target hint is unknown, we do not perform any default conversion.
	\note If m_conversionMatrix is set to non-null, this overrides standard conversion and we multiply this matrix as follows
		For all position data (hair vertices, etc.)
			p_converted = p_old * m_conversionMatrix
		For all matrix data (bind pose matrix, etc.)
			M_converted = M_old * m_conversionMatrix. */
struct ConversionSettings
{
	NV_DECLARE_CLASS_BASE(ConversionSettings);

	EAxisHint m_targetUpAxisHint;				//!< up axis used by the game engine that will use this asset in runtime
	EHandednessHint m_targetHandednessHint;	//!< handedness of original tools that generated this asset
	gfsdk_float4x4*	m_conversionMatrix;				//!< If not NV_NULL, we use this conversion matrix instead
	Float32	m_targetSceneUnit;						//!< scene unit (in centimeters) for game engine.  0 means unknown (use source unit)
													// Centimeter (default): 1.0, Meter: 100.0, Inch: 2.54, Decimeter: 10.0
	ConversionSettings() :
		m_targetUpAxisHint(AxisHint::UNKNOWN),
		m_targetHandednessHint(HandednessHint::UNKNOWN),
		m_conversionMatrix(NV_NULL),
		m_targetSceneUnit(0.0f)
	{
	}
};

/*! \brief This abstract class provides all the API for HairWorks runtime */
class HairSdk
{
public:
	/*=============================================================================================
		OVERVIEW

		To use HairWorks runtime, we first need to load the HairWorks dll and create this HairSdk object.
		See loadHairSdk(const Char* dllPath, UInt32 version = NV_HW_VERSION) defined in NvHwWinLoadSdk.h.
		Once SDK's DLL is loaded, we can use the HairSdk object to access all the APIs below.
		When HairSdk is not needed (typically at the shutdown stage of a game), call release().
	=============================================================================================*/

		///  brief Deletes this SDK object. 
	virtual void release() = 0;

	/*=============================================================================================
		HAIR ASSET PREPARATION AND MANAGEMENT

		The first step is to get hair asset created and loaded, and get hair asset ID.
		The hair assets can be either created manually or loaded from a file (.apx/.apb).
		
		See functions below.
	=============================================================================================*/

	/*! \brief loads hair asset data from descriptor. 
		\param [in] assetDesc The hair asset descriptor created from apx file, etc.
		\param [out] assetIdOut Upon success, assetID is filled by a valid HairAssetId value.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result createHairAsset(const HairAssetDescriptor& assetDesc, HairAssetId& assetIdOut) = 0;

	/*! \brief destroy/release hair asset data
		\param [in] assetId hair asset ID to delete */
	virtual void freeHairAsset(const HairAssetId assetId ) = 0;

		/*! \brief returns the serialized format implied by the extension.
		  \param [in] ext The filename extension.
		  \return The associate file format or SerializeFormat::UNKNOWN if not known */ 
	virtual ESerializeFormat getSerializeFormatFromExtension(const char* ext) = 0;
		
	/*! \brief load hair asset data from a memory buffer that contains (.apx/.apb) file content
		\param [in] stream ReadStream that will be read from.
		\param [out] assetIdOut Upon success, assetID is filled by a valid HairAssetId value.
		\param [out] infoOut If the info is not NV_NULL, the info is filled upon success.
		\param [in] settings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See ConversionSettings.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result loadHairAsset(ReadStream* stream, HairAssetId& assetIdOut, HairWorksInfo* infoOut = NV_NULL, const ConversionSettings* settings = NV_NULL) = 0;
	
	/*! \brief save hair asset data to an (.apx/.apb) file
		\param [in] stream WriteStream that the asset will be serialized out to 
		\param [in] format The ESerializeFormat that defines what format the data will be written in.
		\param [in] assetId hair asset ID to store.
		\param [in] descriptor Instance descriptor to save in file.  If this is NV_NULL, default instance descriptor for the asset will be saved.
		\param [in] info file header info to be stored. info can be NV_NULL.
		\param [in] textureNames Set texture file names if different from the names in the original asset. If NV_NULL, texture file names loaded from original asset will be saved.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveHairAsset(WriteStream* stream, ESerializeFormat format, HairAssetId assetId, const HairInstanceDescriptor* descriptor = NV_NULL, const HairWorksInfo* info = NV_NULL, const Char*const* textureNames = NV_NULL) = 0;
	
	/*! \brief save hair instance data to an (.apx/.apb) file
		\param [in] stream WriteStream that the instance will be serialized out to
		\param [in] format The ESerializeFormat that defines what format the data will be written in.
		\param [in] instanceId hair instance ID to save.
		\param [in] info file header info to be stored. info can be NV_NULL.
		\param [in] textureNames Set texture file names if different from the names in the original asset. If NV_NULL, texture file names loaded from original asset will be saved.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveHairInstance(WriteStream* stream, ESerializeFormat format, HairInstanceId instanceId, const HairWorksInfo* info = NV_NULL, const Char*const* textureNames = NV_NULL) = 0;

	/*! \brief copy some parts of assets from one asset to another
		\param[in] fromAssetId asset id to copy property from
		\param[in] toAssetId asset id to copy property to
		\note Useful for importing certain part of asset data.  fromAssetID and toAssetID cannot be the same.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result copyAsset(HairAssetId fromAssetId, HairAssetId toAssetId, const AssetCopySettings& settings = AssetCopySettings()) = 0;

	/*! \brief Get hair default instance descriptor from the asset.
		\param [in] assetId hair asset id that holds the default instance descriptor
		\param [inout] descriptorOut Hair instance descriptor to copy the data to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getInstanceDescriptorFromAsset(HairAssetId assetId, HairInstanceDescriptor& descriptorOut) = 0;

	/*! \brief resample number of cvs to target number
		\param[in] assetId asset identifier to resample
		\param[in] numTargetPointsPerHair number of cvs for each hair
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result resampleGuideHairs(HairAssetId assetId, Int numTargetPointsPerHair) = 0;

	/*=============================================================================================
		HAIR SHADER CACHE MANAGEMENT

		HairWorks provides options to create optimized shader for each specific asset.
		By removing unused features, performance can be significantly improved. 
		This 'cooking' process can be performed before game runs and does not require D3D device or context.
		This process can be done as preprocess once all the assets are locked for game release.

		Use the following functions to create, store, and load optimized shader caches.
		NOTE: If shader cache is not defined, HairWorks will run in unoptimized mode.
	=============================================================================================*/

	/*! \brief clear entire shader cache database
		\details call this function in the beginning of shader cache cooking process.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result clearShaderCache() = 0;

	/*! \brief add new shader cache based on specified shader settings
		\details add shader to the cache with specified settings
		\param[in] settings flags that affect shader cache generation.  If matching shader already exists, this will be skipped.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result addToShaderCache(const ShaderCacheSettings& settings) = 0;

	/*! \brief Save serialized shader cache.
		\details Once caches has been added, use this function to get serialized cache buffer. Users can write this data to their own file format for future use. 
		NOTE! That the file format is platform, HW API, and graphics Api dependant. Trying to load a shader cache that doesn't match has undefined behavior
		\param[in] stream WriteStream that the shader cache is filled with. 
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveShaderCache(WriteStream* stream) = 0;

	/*=============================================================================================
		RENDERER INITIALIZATION

		Once the game starts running and DX device is prepared, we should call initRenderResources() once for HairSdk to 
		consequently manage internal DX resources.
	=============================================================================================*/

	/*! \brief Initialize internal render state variables and shaders. On DX11 this will be a ID3D11Device and ID3D11DeviceContext respectively. 
		To pass those parameters, make sure you include <Nv/Platform/Dx11/Foundation/NvDx11Handle.h>, and to call the method wrap them like so
		ID3D11Device* device = ...;
		ID3D11DeviceContext* context = ...;
		hairSdk->initRenderResources(Dx11Type::getHandle(device), Dx11Type::getHandle(context));
		\param [in] device The DX11 device that HairWorks should use to create all the DX11 resources
		\param [in] context When d3d context is known at time of calling this function, set it here. If not use setCurrentContext() later.	
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result initRenderResources(const ApiDevice& device, const ApiContext& context = ApiContext::getNull()) = 0;

	/*! \brief Load previously cooked shader cache.
		\details This fills internal shader cache from serialized data that was generated by saveShaderCacheToMemory() function calls.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result loadShaderCache(ReadStream* stream) = 0;

	/*! \brief Clean up all the internally used DX11 resources.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual void freeRenderResources() = 0;

	/*! \brief set current rendering context. 
		\detail All subsequent HairWorks calls will use this context for simulation and rendering
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result setCurrentContext(const ApiContext& context) = 0;

	/*=============================================================================================
		HAIR INSTANCE MANAGEMENT

		Given properly initialized HairSdk object and hair asset ID, we can now instantiate an actual 
		hair instance object anytime during the game play, allowing hair creatures to be dynamically 
		spawned/deleted on the fly.
		All the control parameters defined in the HairInstanceDescriptor can be updated anytime.
		Control textures for the parameters can be set either using D3D SRV, 
		and these can be set anytime once hair instance has been created.
	=============================================================================================*/

	/*! \brief Create a hair instance from given asset type
		\param [in] assetId hair asset type to create a hair instance from.  
					The assetId should have been generated from a successful call of HairSdk.loadHairAsset().
		\param [out] instanceIdOut If a hair instance was successfully created, an ID value is written to this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result createHairInstance(HairAssetId assetId, HairInstanceId& instanceIdOut) = 0;

	/*! \brief Delete a given hair instance
		\param [in] instanceId hair instance to delete
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result freeHairInstance(HairInstanceId instanceId) = 0;

	/*! \brief Get currently used instance descriptor for the chosen hair instance 
		\param [in] instanceId hair instance id to get the instance descriptor
		\param [inout] descriptor Hair instance descriptor to copy the data to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getInstanceDescriptor(HairInstanceId instanceId, HairInstanceDescriptor& descriptorOut) = 0; 

	/*! \brief Update hair instance parameters
		\details One can change rendering/simulation parameters by updating hair instance descriptor.  
					This can be called at any time during runtime, but typically called before 
					either HairSdk.renderHairs() or HairSdk.stepSimulation() calls.
		\param [in] instanceId hair instance to update.
		\param [in] descriptor hair instance descriptor to update.
		\param [in] [optional] which material set to update when there are multiple material sets
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result updateInstanceDescriptor( HairInstanceId instanceId, const HairInstanceDescriptor& descriptor) = 0;

	/*! \brief Set texture resource for control textures
		\param [in] instanceId hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [in] texture input texture, note texture resource should be managed by game itself. (ID3D11ShaderResourceView on Dx11)
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result setTexture(HairInstanceId instanceId, EHairTextureType textureType, const ApiHandle& texture) = 0;

	/*! \brief Get texture resource for control textures
		\param [in] instanceId hair instance to update texture
		\param [in] types the texture types wanted - pass NV_NULL for all texture types (numTextures must be set to HairTextureType::COUNT_OF)
		\param [in] numTextures
		\param [out] texturesOut textures for each textureType and instance.  (ID3D11ShaderResourceView* on Dx11)
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getTextures(HairInstanceId instanceId, const EHairTextureType* types, Int numTextures, const ApiPtr& texturesOut) = 0;

	/*! \brief Get shader resource for attribute interpolation
		\detail Shader attributes such as tangent, normal, etc. can be mapped to custom pixel shader.
		    This function fills SRVs necessary for such mapping.  See sample codes.
		\param [in] instanceId hair instance to get SRVs
		\param [in] shader resource types wanted (NV_NULL for all the types of numResources should equal ShaderResourceType::COUNT_OF).
		\param [in] numResources  the size of the array that resourcesOut points to. 
		\param [out] resourcesOut array of resources. (ID3D11ShaderResourceView* on Dx11)
			See EShaderResourceType for the actual resource types.
			use NV_HW_DECLARE_SHADER_RESOURCES() function in the shader to assign resource slot for each resource. */
	virtual Result getShaderResources(HairInstanceId instanceId, const EShaderResourceType* types, Int numResources, const ApiPtr& resourcesOut) = 0;

	/*=============================================================================================
		ANIMATION AND SIMULATION

		To move and animate hairs, a typical process is to give it an animation first, by updating 
		bones used to skin animated hair shapes.  The bone data can be either in the form of 
		standard linear matrices (HairSdk.updateSkinningMatrices) or dual quaternions (HairSdk.updateSkinningDqs).
		Once skinning bones are set, we call HairSdk.stepSimulation() to further simulation motion of hairs for each frame.
		We allow maximum of 4 bones per each hair, see HairAssetDescriptor.m_boneIndices and HairAssetDescriptor.m_boneWeights.
	=============================================================================================*/

	/*! \brief update skinning matrices by linear matrices
		\param [in] instanceId hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the HairAssetDescriptor.
		\param [in] skinningMatrices array of linear skinning matrices
		\param [in] teleportMode teleport mode if any teleport option is used
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note A skinning matrix is defined as world space bone transform applied after inverse transform of the bind pose of the bone.
			When only world space bone matrix is available, one can use HairAssetDescriptor.m_bindPoses to get the bind pose, to construct the skinning matrix.
		\note The bone order should match the one defined in HairAssetDescriptor.m_boneNames.  
			The bone name can be also retrieved by HairSdk.getBoneName() as well.  
			Make sure that the bone ordering is consistent between hair asset and characters used in the host application. */
	virtual Result updateSkinningMatrices( HairInstanceId instanceId, Int numBones, const gfsdk_float4x4* skinningMatrices, ETeleportMode teleportMode = TeleportMode::NONE) = 0;

	/*! \brief update skinning matrices by dual quaternions
		\param [in] instanceId hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the HairAssetDescriptor.
		\param [in] dqs array of dual quaternions.
		\param [in] teleportMode teleport mode if any teleport option is used
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result updateSkinningDqs(HairInstanceId	instanceId, Int numBones, const gfsdk_dualquaternion* dqs, ETeleportMode teleportMode = TeleportMode::NONE) = 0;

	/**
		\brief Runs simulation for all currently active hair instances for one frame.
		\details Compute GPU skinning for hair and run hair simulation for all the active hair instances.
		\param [in] timeStepSize simulation time step size in second for one frame.  Typically we sync with display fps (60).
		\param [in] worldReference This is useful when world containing hair itself is moving, but motion due to moving world is not desired and needs to be canceled out. 
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result stepSimulation( Float timeStepSize = 1.0f / 60.0f, const gfsdk_float4x4* worldReference = NV_NULL) = 0;
	
	/*! \brief Returns a conservative bounds for hairs.
		\param [in] instanceId hair instance to get the bounds information
		\param [out] bbMinOut If not NV_NULL, minimum bounds will be written here.
		\param [out] bbMaxOut If not NV_NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note This function is intended for approximate, but fast culling purpose.
			This does not return exact bounds, but rather conservative bounds that are guaranteed to enclose all hairs regardless of current simulation/animation changes. */
	virtual Result getBounds(HairInstanceId	instanceId, gfsdk_float3& bbMinOut, gfsdk_float3& bbMaxOut, Bool growthMeshOnly = false) = 0;

	/*=============================================================================================
		RENDERING HAIRS

		To render hairs, we first set global variables such as camera (HairSdk.setViewProjection).
		For each hair instance, we then call HairSdk.RenderHairs() function to render hairs to current render target.
		\note renderHairs() call requires users to provide and properly set shaders.  See accompanying sample codes.

	=============================================================================================*/
		
	/*! \brief set camera projection for rendering to a cubemap */
	virtual void setCubeMapViewProjection(const gfsdk_float4x4 view[6], const gfsdk_float4x4 proj[6], const bool visibility[6], EHandednessHint handedness = HandednessHint::RIGHT) = 0;

	/*! \brief set camera projection matrices
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] fov field of view in angles.
		\param [in] handedness Whether the provided view projection matrices use left handed or right handed coordinate system
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note It is important to set camera properly before rendering or simulation, 
				as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is possible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionality such as backface culling may behave incorrectly. */
	virtual Result setViewProjection(const gfsdk_float4x4& view, const gfsdk_float4x4& proj, EHandednessHint handedness = HandednessHint::RIGHT, Float fov = 70.0f) = 0;

	/*! \brief set previous camera projection matrices for pixel velocity attributes, etc.
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] fov field of view in angles.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note It is important to set camera properly before rendering or simulation,  as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass. 
				The handedness is assumed to be the same as with setViewProjection.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is possible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionality such as backface culling may behave incorrectly */
	virtual Result setPrevViewProjection(const gfsdk_float4x4& view, const gfsdk_float4x4& proj, Float fov = 70.0f) = 0;

	/*! \brief fill constant buffer for custom hair shading
		\details This function fills constant buffer data structure ShaderConstantBuffer for binding custom constant buffer in connection with custom hair pixel shader.
		\param [in] instanceId hair instance to render
		\param [out] constantBuffer The context of provided constant buffer structure will be filled.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note setViewProjection() function should be called before using this function to get proper view/camera data in the constant buffer. */
	virtual Result prepareShaderConstantBuffer(HairInstanceId instanceId, ShaderConstantBuffer& constantBufferOut) = 0;

	/** \brief render a hair instance to the current render target.
		\details This function does the main hair rendering.  
		\param [in] instanceId hair instance to render
		\param [in] shaderSettings users can customize various aspects of hair shaders using HairShaderSettings.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result renderHairs(HairInstanceId instanceId, const ShaderSettings* shaderSettings = NV_NULL) = 0;		

	/*! \brief render visualization functions
		\param [in] instanceId hair instance to render
		\details This function renders all the auxiliary visualization options given in the HairInstanceDescriptor.
			These can be useful for debugging and verification purposes.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result renderVisualization( HairInstanceId instanceId) = 0;

	/*=============================================================================================
		CUSTOM MSAA FUNCTIONS

		Some engines may not have MSAA enabled render targets.
		In this case, user can use custom MSAA render targets just for HairWorks, and composite the result
		to non-msaa buffer. 
		This may be particularly useful for non-MSAA deferred rendering solutions.
	=============================================================================================*/

	/*! \brief Prepare custom MSAA buffer, and switch render target to this custom buffer.
		\param [in] sampleCount number of MSAA samples.  If 0, we simply disable msaa.
			Allowed sample counts are 1, 2, 4, 8.
		\param [in] depthCompareLess Whether depth test is 'less than' or 'greater than' for proper depth resolve.
		\return Successful if NV_SUCCEEDED(Result) is true. */	
	virtual Result startMsaaRendering(Int sampleCount, Bool depthCompareLess) = 0;

	/*! \brief Once all hairworks render calls are finished, use this function to switch back to original render target and perform MSAA resolve.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result finishMsaaRendering() = 0;
	
	/*! \brief Draw MSAA resolved color buffer to current render target.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result drawMsaaColor() = 0;

	/*! \brief Draw MSAA resolved depth buffer to current depth target.
		\param [in] emitPartialFragment when true, we write depth from partial fragment (alpha < 1.0).
		\return Successful if NV_SUCCEEDED(Result) is true. */	
	virtual Result drawMsaaPostDepth(Bool emitPartialFramgment = true) = 0;

	/*=============================================================================================
		UTILITY FUNCTIONS

		Use the following functions to query further info/states of the HairWorks runtime.
		These functions are not need to just run the HairWorks, but could be useful for debugging/profiling purposes.
	=============================================================================================*/
	/*! \brief Use this function to get the build string which includes build location and date/time */
	virtual const Char* getBuildString() = 0;

	/*! \brief return number of guide hairs in the asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumGuideHairs(HairAssetId assetId) = 0;

	/*! \brief return number of hair vertices in the asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumHairVertices( HairAssetId assetId) = 0;

	/*! \brief return number of faces of the growth mesh in the asset
 		\param [in] assetId hair asset ID to use */
	virtual Int getNumFaces( HairAssetId assetId) = 0;

	/*! \brief get control vertices of the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] verticesOut data to copy from the asset. It should be pre-allocated to at least number of hair control vertices * sizeof(gfsdk_float3).
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getHairVertices( HairAssetId assetId, gfsdk_float3* verticesOut) = 0;

	/*! \brief get root vertices (growth mesh vertices) of the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] verticesOut data to copy from the asset.  It should be pre-allocated to at least number of hair curves * sizeof(gfsdk_float3).
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getRootVertices(HairAssetId assetId, gfsdk_float3* verticesOut) = 0;

	/*! \brief get end indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] indicesOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getEndIndices(HairAssetId assetId, UInt32* indicesOut) = 0;

	/*! \brief get face indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] indicesOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getFaceIndices(HairAssetId assetId, UInt32* indicesOut) = 0;

	/*! \brief get face uvs from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] uvsOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getFaceUvs(HairAssetId assetId, gfsdk_float2* uvsOut) = 0;

	/*! \brief changes bone order based on new bone names
		\param [in] assetId hair asset ID to apply bone remapping
		\param [in] boneNames bone names used in new ordering
		\param [in] numBones number of bones in new ordering
		\detail This function changes bone ordering of current hair asset identified by assetID.
			In case in-game bone orders are different, or when game uses reduced number of bones compared to asset stored in .apx file,
			users can change (and optionally resave the asset) bone settings with this API.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note If original bone name from asset does not exist in new bone names, behaviors for hair vertices affected by the omitted bones can be undefined. */
	virtual Result setBoneRemapping( HairAssetId assetId, const Char*const*	boneNames, Int numBones) = 0;
	
	/*! \brief get number of bones used in the specified hair asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumBones(HairAssetId assetId) = 0;
	
	/*! \brief get bone name from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] boneId bone id to use
		\param [out] boneNameOut bone name gets copied into this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneName(HairAssetId assetId, Int boneId, Char* boneNameOut) = 0;

	/*! \brief bind pose matrix from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] boneId bone id to use
		\param [out] bindPoseOut bind pose data to copy the matrix to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBindPose(HairAssetId assetId, Int boneId, gfsdk_float4x4*	bindPoseOut) = 0;

	/*! \brief get bone indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] boneIndicesOut bone indices array to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneIndices(HairAssetId assetId, gfsdk_float4* boneIndicesOut) = 0;

	/*! \brief get bone weights from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] boneWeightsOut bone weights array to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneWeights(HairAssetId assetId, gfsdk_float4* boneWeightsOut) = 0;

	/*!\brief get texture file name from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] textureId texture id to use
		\param [out] textureNameOut texture name gets copied into this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getTextureName(HairAssetId assetId, EHairTextureType textureType, Char* textureNameOut) = 0;

	/*!\brief get number of pins used in the specified hair asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumPins(HairAssetId assetId) = 0;

	/*!\brief get a range of pins. startIndex + numPins <= getNumPins().
		\param [in] assetId hair asset ID to use
		\param [in] startIndex start index of pins to get in the specified hair asset's pin array
		\param [in] numPins number of pins to get
		\param [out] pinsOut pin array to copy data to */
	virtual void getPins(HairAssetId assetId, Int startIndex, Int numPins, Pin* pinsOut) = 0;

	/*!\brief set a range of pins. startIndex + numPins <= getNumPins().
		\param [in] assetId hair asset ID to use
		\param [in] startIndex start index of pins to set in the specified hair asset's pin array
		\param [in] numPins number of pins to set
		\param [in] pins pin array to copy data from */
	virtual void setPins(HairAssetId assetId, Int startIndex, Int numPins, const Pin* pins) = 0;

	/* !\brief get statistics about a hair instance
		\param[in] instanceId hair instance id to pull stats from
		\param[out] statsOut pointer to HairStats struct
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result computeStats(HairInstanceId instanceId, HairStats& statsOut) = 0;

	/* !\brief get matrix of a specified pin
		\param[in] instanceId hair instance id to specify the hair instance the specified pin belongs to
		\param[in] pinIndex index of the specified pin
		\param[out] matrixOut reference to the matrix */
	virtual Void getPinMatrix(HairInstanceId instanceId, Int pinIndex, gfsdk_float4x4& matrixOut) = 0;
};

} // namespace HairWorks
} // namespace Nv

#endif
