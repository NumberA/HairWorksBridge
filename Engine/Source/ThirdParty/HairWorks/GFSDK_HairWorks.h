// This code contains NVIDIA Confidential Information and is disclosed 
// under the Mutual Non-Disclosure Agreement. 
// 
// Notice 
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES 
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO 
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT, 
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. 
// 
// NVIDIA Corporation assumes no responsibility for the consequences of use of such 
// information or for any infringement of patents or other rights of third parties that may 
// result from its use. No license is granted by implication or otherwise under any patent 
// or patent rights of NVIDIA Corporation. No third party distribution is allowed unless 
// expressly authorized by NVIDIA.  Details are subject to change without notice. 
// This code supersedes and replaces all information previously supplied. 
// NVIDIA Corporation products are not authorized for use as critical 
// components in life support devices or systems without express written approval of 
// NVIDIA Corporation. 
// 
// Copyright (c) 2013-2015 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and proprietary
// rights in and to this software and related documentation and any modifications thereto.
// Any use, reproduction, disclosure or distribution of this software and related
// documentation without an express license agreement from NVIDIA Corporation is
// strictly prohibited.
//

/*

-----------------------------------------------------------------------------
                                   HairWorks                                 
-----------------------------------------------------------------------------

NVIDIA HairWorks enables users to simulate and render fur/hair to provide a 
truly interactive game experience. The technology originates from multiple 
simulation and rendering technologies that NVIDIA has developed in the past. 
This combines rendering technologies for human hair (GDC 2008) as well as 
various simulation technologies shown in multiple events (Fur Demo - GDC2012).

To make the hair/fur technologies a product, NVIDIA engineers have put
together these existing technologies and added new techniques to ensure a 
smooth pipeline for a variety of characters.

-----------------------------------------------------------------------------
                             INTEGRATION EXAMPLE                             
-----------------------------------------------------------------------------

This is an overview of the integration. Please refer to the API documentation
in the header file and the sample code for details.

(1.) LOAD THE LIBRARY

	#include "GFSDK_HairWorks.h" // hairworks main header file

	GFSDK_HairSDK* g_pHairSDK = GFSDK_LoadHairSDK("GFSDK_HairWorks.win64.dll",
	                                              GFSDK_HAIRWORKS_VERSION);

(2.) INITIALIZE

Initialize D3D Device.

	g_pHairSDK->InitRenderResources(pd3dDevice);

Create the hair asset manually from your asset data

	GFSDK_HairAssetDescriptor hairAssetDescriptor;
	hairAssetDescriptor.m_NumGuideHairs = 4;
	hairAssetDescriptor.m_NumVertices = 20;
	hairAssetDescriptor.m_pVertices = vertices;
	hairAssetDescriptor.m_pEndIndices = endIndices;
	hairAssetDescriptor.m_pBindPoses = bindPoses;
	hairAssetDescriptor.m_pBoneParents = boneParents;
	...
	g_pHairSDK->CreateHairAsset(g_hairAssetDescriptor, &g_hairAssetID);

Or load it from the .apx file (generated by DCC tool or FurViewer) using the API.
	
	g_pHairSDK->LoadHairAssetFromFile("test.apx", &g_hairAssetID);

Create a hair instance from the hair asset.

	g_pHairSDK->CreateHairInstance(g_hairAssetID, &hairInstanceID);

(3.) SIMULATION/RENDERING

Set render context for HairWorks.

	g_pHairSDK->SetCurrentContext(pd3dContext);

Update descriptor parameters for each hair instance.

	GFSDK_HairInstanceDescriptor hairInstanceDescriptor;
	hairInstanceDescriptor.m_width = 0.2;
	hairInstanceDescriptor.m_density = 1.0;
	hairInstanceDescriptor.m_lengthNoise = 0.0f;
	hairInstanceDescriptor.m_simulate = true;
	...
	g_pHairSDK->UpdateInstanceDescriptor(hairInstanceID, hairInstanceDescriptor);

Update skinning matrices for each hair
	g_pHairSDK->UpdateSkinningMatrices(hairInstanceID, numBones, pMatrices); 

Run simulation for all hairs.

	g_pHairSDK->StepSimulation(fElapsedTime);

Set view matrix and projection matrix.

	D3DXMATRIX projection = *g_Camera.GetProjMatrix();
	D3DXMATRIX view = *g_Camera.GetViewMatrix();
	g_pHairSDK->SetViewProjection((const gfsdk_float4x4*)&view,(const gfsdk_float4x4*)&projection);

Set your hair pixel shader before rendering hairs.

	pd3dContext->PSSetShader(g_customHairWorksShader, NULL, 0);

Render each hair instance.

	g_pHairSDK->RenderHairs(hairInstanceID);

(4.) RELEASE

	g_pHairSDK->FreeHairInstance(hairInstanceID);
	g_pHairSDK->FreeHairAsset(hairAssetID);
	g_pHairSDK->FreeRenderResources();
	g_pHairSDK->Release();

*/

#ifndef __GFSDK_HAIRWORKS_H__
#define __GFSDK_HAIRWORKS_H__

#include "GFSDK_HairWorks_Common.h"

#include <dxgi.h>
#include <d3d11.h>

#define GFSDK_HAIRWORKS_VERSION 1111 // internal version number to match runtime DLLs. 
#define GFSDK_HAIRWORKS_FILE_VERSION_STRING "1.1" // version string for .apx file format

/**
	\brief Dual Quaternion data used for dual quaternion skinning option
	\details Defines a dual quaternion structure with 2 pairs of gfsdk_float4.  
				First gfsdk_float4 is interpreted as normal quaternion and the second gfsdk_float4 is interpreted as dual quaternion.
*/
struct gfsdk_dualquaternion
{
	gfsdk_float4 q0; // first quaternion
	gfsdk_float4 q1; // second (dual) quaternion

	gfsdk_dualquaternion() {}

	gfsdk_dualquaternion(const gfsdk_float4 iq0, const gfsdk_float4 iq1) : q0(iq0), q1(iq1) {}
};

/**
	\brief Identifier for hair asset data.
	\details The asset id is assigned by HairWorks SDK, and corresponds to a unique asset type.
	\see HairSDK.LoadHairAsset()
*/
enum GFSDK_HairAssetID
{
	GFSDK_HairAssetID_NULL = 0xFFFF	//!< invalid hair asset ID
};

/**
	\brief Identifier for a hair instance
	\details Multiple hair instances can be created from a single asset type.  
	\see HairSDK.CreateHairInstance() and HairSDK.FreeHairInstance()
*/
enum GFSDK_HairInstanceID
{
	GFSDK_HairInstanceID_NULL = 0xFFFF //!< invalid hair instance ID
};

/**
	\brief Error code for all HairSDK functions.
	\details Every function under GFSDK_HairSDK returns this error code, based on results.
	GFSDK_RETURN_OK is returned when the function proceeds successfully, 
	and GFSDK_RETURN_FAIL is returned when there is an error.
*/
enum GFSDK_HAIR_RETURNCODES
{
  GFSDK_HAIR_RETURN_OK						=	GFSDK_RETURN_OK,	//!< succeeded
  GFSDK_HAIR_RETURN_FAIL					=	GFSDK_RETURN_FAIL,	//!< unknown failure
  GFSDK_HAIR_RETURN_OPEN_FAILED,									//!< file or stream open(or write) failed
  GFSDK_HAIR_RETURN_INVALID_PARAMETERS,								//!< invalid options to the method
  GFSDK_HAIR_RETURN_INVALID_FORMAT,									//!< invalid file or memory format
  GFSDK_HAIR_RETURN_VERSION_MISMATCH,								//!< not supported version
};

/**
	\brief Log types to filter log messages
	\details Log messages can be filtered by its log type.
	\see GFSDK_HAIR_LogHandler
*/
enum GFSDK_HAIR_LOG_TYPES
{
	GFSDK_HAIR_LOG_ERROR   = 0, //!< error messages
	GFSDK_HAIR_LOG_INFO    = 1, //!< information messages
	GFSDK_HAIR_LOG_WARNING = 2, //!< warning messages
	GFSDK_HAIR_LOG_DEBUG   = 4, //!< used only in debug version of dll
	GFSDK_HAIR_LOG_ALL     = -1, //!< all log types
};

/**
	\brief Base class for custom log handler
	\details To get the log/error messages, inherit this class and implement the virtual method Log().
	         You can print the message to a file or to an output window, or you can just ignore.
	\see GFSDK_HAIR_LOG_TYPES
*/
class GFSDK_HAIR_LogHandler
{
public:
	virtual ~GFSDK_HAIR_LogHandler() {}

	/**
		\brief Derived class should implement this method to handle the log message.
		\param [in] logType The log type for the message
		\param [in] message The message string
		\param [in] file The filename that outputs the message
		\param [in] line The line number of the file that outputs the message
	*/
	virtual void Log(GFSDK_HAIR_LOG_TYPES logType, const char* message, const char* file, int line) = 0;
};

///maximum allowed size for name string
#define GFSDK_HAIR_MAX_STRING	128 
///maximum allowed size for GFSDK_HairWorksInfo member variable's string
#define GFSDK_HAIR_MAX_INFO_STRING	1024

/**
	\brief Coordinate system setting for file import and camera view projection
	\details Handedness of coordinate system may affect internal HairWorks computation dependent on camera such as culling and shading.
*/
enum GFSDK_HAIR_HANDEDNESS_HINT
{
	GFSDK_HAIR_HANDEDNESS_UNKNOWN, //!< don't know the handedness, use best guess.
	GFSDK_HAIR_RIGHT_HANDED, //!< uses a right handed system (Z is pointing toward the viewer)
	GFSDK_HAIR_LEFT_HANDED,  //!< uses a left handed system ( Z is pointing away from the viewer)
};

/**
	\brief Up axis setting of the asset
	\details When up axis is different between original DCC tool and HairWorks runtime, provide this info to the file loading APIs.
	\see GFSDK_HairImportSettings
*/
enum GFSDK_HAIR_UP_AXIS_HINT
{
	GFSDK_HAIR_UP_AXIS_UNKNOWN, //!< don't know the up axis, use best guess.
	GFSDK_HAIR_Y_UP,  //!< camera is y-up
	GFSDK_HAIR_Z_UP,  //!< camera is z-up
};
/**
	\brief HairWorks file header

	\details Contains info about this file.

	\note If the version is matched, GFSDK_HairSDK.LoadHairAsset() fails.
*/
struct GFSDK_HairWorksInfo
{
	gfsdk_char		m_fileVersion[GFSDK_HAIR_MAX_INFO_STRING];	//!< file format version
	gfsdk_char		m_toolVersion[GFSDK_HAIR_MAX_INFO_STRING];	//!< tool version
	gfsdk_char		m_sourcePath[GFSDK_HAIR_MAX_INFO_STRING];	//!< source asset path
	gfsdk_char		m_authorName[GFSDK_HAIR_MAX_INFO_STRING];	//!< author name
	gfsdk_char		m_lastModified[GFSDK_HAIR_MAX_INFO_STRING]; //!< last modified date and time in format "YYYY-MM-DD HH:MM:SS"

	GFSDK_HairWorksInfo()
	{
		m_fileVersion[0] = '\0';
		m_toolVersion[0] = '\0';
		m_sourcePath[0] = '\0';
		m_authorName[0] = '\0';
		m_lastModified[0] = '\0';
	}
};

/**
	\brief Describes each collision sphere attached to a bone
	\details To enable collision handling between sphere and/or capsule and hair curves, we define a 'boneSphere',
		a sphere whose center is attached to one of the bones used for skinning hairs.
		One can assign radius as well as initial offset with regard to the bind pose of the attached bone.
*/
struct gfsdk_boneSphere
{
	gfsdk_U32		m_BoneSphereIndex;		//!< index for the bone where the collision sphere is attached to
	gfsdk_F32		m_BoneSphereRadius;		//!< radius for the collision sphere
	gfsdk_float3	m_BoneSphereLocalPos;	//!< offset value with regard to bind position of the bone
};

/**
	\brief Descriptor to specify hair asset (hair curves, growth mesh, skinning weights, bone info...)

	\details Hair assets are defined in memory with this data structure, and comprises important part of the hair asset data (.apx) file format.
	This structure defines a minimal static data needed to create hairs in HairWorks.
	A minimal hair assets consists of guide curve data typically exported from DCC tools, and growth mesh face index/uv data.
	Note that vertices of the growth mesh are required to match the root positions of hair guide curves, 
	so it is automatically derived from the curve data without being explicitly stored in the data structure.
	The skinning information (bone index, weight) is derived from that of the growth mesh, and we use skinning info
	to compute target (skinned) positions for each guide hair.  Same bone index/weights are used for CVs of each guide hair.

	\note When the data is invalid, GFSDK_HairSDK.LoadHairAsset() rejects the hair asset.
	\see All dynamic parameters per hair instance are defined in GFSDK_HairInstanceDescriptor.
*/
struct GFSDK_HairAssetDescriptor
{
	gfsdk_U32		m_NumGuideHairs;//!< number of hair guide hair curves
	gfsdk_U32		m_NumVertices;	//!< total # of cv(control vertices) in guide curves
	gfsdk_float3*	m_pVertices;	//!< all the cv positions of guide curves
	gfsdk_U32*		m_pEndIndices;	//!< index of last vertex for each hair curve pointing to the m_pVertices array
									//!< size of this array should be 'm_NumGuideHairs'	

	gfsdk_U32		m_NumFaces;		//!< number of hair triangles, we grow hairs for each mesh triangles
	gfsdk_U32*		m_pFaceIndices; //!< triangle indices for hair faces, size must be 3 * m_NumFaces
	gfsdk_float2*	m_pFaceUVs;		//!< uv values for hair faces, size must be 3 * m_NumFaces

	gfsdk_U32		m_NumBones;		//!< number of bones used to skin hair curves
	gfsdk_float4*	m_pBoneIndices; //!< size should be 'm_NumGuideHairs'. each mesh vertex (hair root) can have up to 4 bone indices.
	gfsdk_float4*	m_pBoneWeights; //!< size should be 'm_NumGuideHairs'. each mesh vertex (hair root) can have up to 4 bone weights.

	gfsdk_char*		m_pBoneNames;	//!<[OPTIONAL] names for each bone used to check if bone names match. buffer size should be at least GFSDK_HAIR_MAX_STRING * 'm_NumBones'.
	gfsdk_float4x4*	m_pBindPoses;	//!<[OPTIONAL] bind pose matrices for each bone. buffer size should be at least sizeof(gfsdk_float4x4) * m_NumBones.
	gfsdk_S32*		m_pBoneParents; //!<[OPTIONAL] parent index for each bone.  if this is a root bone, the index will be -1. buffer size should be at least sizoef(gfsdk_S32) * m_NumBones.

	gfsdk_U32		m_NumBoneSpheres; //!< [OPTIONAL] collision spheres used for collision handling between body and hair 
	gfsdk_boneSphere* m_pBoneSpheres; //!< [OPTIONAL] collision sphere data, each sphere is attached to a bone. The size of this array should be m_NumBoneSpheres.
	gfsdk_U32		m_NumBoneCapsules; //!< [OPTIONAL] capsules are defined by connecting a pair of collision spheres
	gfsdk_U32*		m_pBoneCapsuleIndices; //!< [OPTIONAL] index to the bone spheres, size of this array must be 2 * m_NumBoneCapsules;

	gfsdk_U32		m_NumPinConstraints; //!< [OPTIONAL] spheres used to apply soft constraint to pin hairs around the spheres.
	gfsdk_boneSphere* m_pPinConstraints; //!< [OPTIONAL] constraint sphere data, each sphere is attached to a bone. The size of this array should be m_NumPinConstraints.

	gfsdk_char*		m_pTextureNames; //!< [OPTIONAL] placeholder to load hair texture file names from apx file. The size must be GFSDK_HAIR_MAX_STRING * GFSDK_HAIR_NUM_TEXTURES

	gfsdk_F32		m_sceneUnit; //!< scene unit scale in centimeters used in the tool that generated this asset
								 // Centimeter (default): 1.0.
								 // Meter: 100.0 
								 // Inch: 2.54
								 // Decimeter: 10.0

	GFSDK_HAIR_HANDEDNESS_HINT	m_handedness; //!< handedness of coordinate system this asset used at time of creation/conversion.  See GFSDK_HAIR_HANDEDNESS_HINT.
	GFSDK_HAIR_UP_AXIS_HINT		m_upAxis;	  //!< up axis of coordinate system this asset used at time of creation/conversion.  See GFSDK_HAIR_UP_AXIS_HINT.
	

	GFSDK_HairAssetDescriptor::GFSDK_HairAssetDescriptor() :
		m_NumGuideHairs(0),
		m_NumVertices(0),		
		m_pVertices(0),
		m_pEndIndices(0),

		m_NumFaces(0),
		m_pFaceIndices(0),
		m_pFaceUVs(0),

		m_NumBones(0),
		m_pBoneIndices(0),
		m_pBoneWeights(0),
		m_pBoneNames(0),
		m_pBindPoses(0),
		m_pBoneParents(0),

		m_NumBoneSpheres(0),
		m_pBoneSpheres(0),
		m_NumBoneCapsules(0),
		m_pBoneCapsuleIndices(0),

		m_NumPinConstraints(0),
		m_pPinConstraints(0),

		m_pTextureNames(0),

		m_sceneUnit(1.0f),
	
		m_handedness(GFSDK_HAIR_HANDEDNESS_UNKNOWN),
		m_upAxis(GFSDK_HAIR_UP_AXIS_UNKNOWN)
	{
	}
};

/**
	\brief copy settings for asset import
*/
struct GFSDK_HairAssetCopySettings
{
	bool m_copyGroom;
	bool m_copyCollision;
	bool m_copyTextures;
	bool m_copyConstraints;
	bool m_copyAll;

	GFSDK_HairAssetCopySettings() :
		m_copyAll(true),
		m_copyGroom(true),
		m_copyCollision(true),
		m_copyTextures(true),
		m_copyConstraints(true)
		{
		}
};

/**
	\brief Texture types used for hair control textures
	\details Some parameters for hair shape/shading/simulation can be controlled with more detail by textures.
			Most of these textures are sampled based on (U,V) values derived from the growth mesh.
			It is OK to share same texture resource for multiple texture type.
			Most of textures have a corresponding constant value, and its value gets used as a multiplier to sampled texture values.
	\see HairSDK.SetTextureSRV()
*/
enum GFSDK_HAIR_TEXTURE_TYPE
{
	GFSDK_HAIR_TEXTURE_DENSITY, //<! hair density map [ shape control ]
	GFSDK_HAIR_TEXTURE_ROOT_COLOR, //<! color at the hair root [ shading ]
	GFSDK_HAIR_TEXTURE_TIP_COLOR, //<! color at the hair tip [ shading ]
	GFSDK_HAIR_TEXTURE_WIDTH,  //<! width  [ shape control ]
	GFSDK_HAIR_TEXTURE_STIFFNESS,  //<! stiffness control [ simulation ]
	GFSDK_HAIR_TEXTURE_ROOT_STIFFNESS, //<! stiffness control for root stiffness [simulation]
	GFSDK_HAIR_TEXTURE_CLUMP_SCALE,  //<! clumpiness control [ shape control]
	GFSDK_HAIR_TEXTURE_CLUMP_ROUNDNESS, //<! clumping noise [ shape control]
	GFSDK_HAIR_TEXTURE_WAVE_SCALE, //<! waviness scale [ shape control ]
	GFSDK_HAIR_TEXTURE_WAVE_FREQ, //<! waviness frequency [ shape control ]
	GFSDK_HAIR_TEXTURE_STRAND, //<! texture along hair strand [ shading ]
	GFSDK_HAIR_TEXTURE_LENGTH, //<! length control [shape control] 
	GFSDK_HAIR_TEXTURE_SPECULAR, //<! specularity control [shading ] 
	GFSDK_HAIR_TEXTURE_WEIGHTS, //!< weight texture for multiple material blending [control for all other textures]

	GFSDK_HAIR_NUM_TEXTURES
};

/**
	\brief Texture channel for each control textures
	\details For a single-channel control textures, one can pack multiple control textures into a single texture resource.
		When such packing is used, assign channel for each control texture type.
*/
enum GFSDK_HAIR_TEXTURE_CHANNEL
{
	GFSDK_HAIR_TEXTURE_CHANNEL_RED,
	GFSDK_HAIR_TEXTURE_CHANNEL_GREEN,
	GFSDK_HAIR_TEXTURE_CHANNEL_BLUE,
	GFSDK_HAIR_TEXTURE_CHANNEL_ALPHA
};

enum GFSDK_HAIR_SHADER_RESOURCE_TYPE
{
	GFSDK_HAIR_SHADER_RESOUCE_HAIR_INDICES, //!< face to hair index buffer
	GFSDK_HAIR_SHADER_RESOUCE_TANGENTS, //!< hair tangent buffer for master strands
	GFSDK_HAIR_SHADER_RESOUCE_NORMALS, //!< hair normal buffer for master strands
	GFSDK_HAIR_SHADER_RESOUCE_MASTER_POSITIONS, //!< position for master strand
	GFSDK_HAIR_SHADER_RESOUCE_PREV_MASTER_POSITIONS, //!< previous position for master strands
	GFSDK_HAIR_NUM_SHADER_RESOUCES
};

/**
	\brief Blend mode for strand texture.
	\details When the strand texture is used, the blend mode determines how colors should combine between the 
			strand texture and other color textures (root, tip, etc.)
*/
enum GFSDK_HAIR_STRAND_BLEND_MODE
{
	GFSDK_HAIR_STRAND_BLEND_OVERWRITE, //!< overwrite with strand texture
	GFSDK_HAIR_STRAND_BLEND_MULTIPLY, //!< multiply strand texture to base color (root/tip)
	GFSDK_HAIR_STRAND_BLEND_ADD,	//!< add strand color on top of base color
	GFSDK_HAIR_STRAND_BLEND_MODULATE, //!< add/subtract strand color to/from base color

	GFSDK_HAIR_STRAND_BLEMD_MODE_END,
};

/**
	\brief Colorize option for hair
	\details Different options for colorizing hairs for visualization.
*/
enum GFSDK_HAIR_COLORIZE_MODE
{
	GFSDK_HAIR_COLORIZE_MODE_NONE,
	GFSDK_HAIR_COLORIZE_MODE_LOD, //!< colorize lod factors
	GFSDK_HAIR_COLORIZE_MODE_TANGENTS, //!< colorize hair tangents
	GFSDK_HAIR_COLORIZE_MODE_NORMAL, //!< colorize hair growth mesh normal
	GFSDK_HAIR_COLORIZE_MODE_RED, //!< just constant red color for debugging

	GFSDK_HAIR_COLORIZE_MODE_END,
};

/**
	\brief Teleport mode
	\details Options for teleport control in UpdateSkinningMatrices.
*/
enum GFSDK_HAIR_TELEPORT_MODE
{
	GFSDK_HAIR_TELEPORT_MODE_NONE,  //!< no teleport (keep simulating)
	GFSDK_HAIR_TELEPORT_MODE_TELEPORT_WITH_SKINNED_POSITION, //!< teleport and set simulation state to skinned position
};

/**
	\brief Descriptor to control all aspects of hair (can be updated and animated per fame)
	\details HairWorks provides a unified parameter control for shape, simulation and rendering through GFSDK_HairInstanceDescriptor.
		These parameters can be updated using HairSDK.UpdateInstanceDescriptor() between function calls to render or simulations.
	\note Some parameters are length/scale dependent, and all our default values are optimized for CENTIMETERS.
		If the hair scene uses different unit, all unit dependent parameters can be automatically scaled when GFSDK_HairInstanceDescriptor.m_unitInCentimeters is set correspondingly.
*/
struct GFSDK_HairInstanceDescriptor
{
	// global controls
	gfsdk_bool		m_enable;					//!< [true/false] whether to enable this hair. When disabled, hair will not cause any computation/rendering

	// hair geometry (density/width/length/clump) controls
	gfsdk_F32		m_width;					//!< [In Millimeters] hair width (thickness)
	gfsdk_F32		m_widthNoise;				//!< [0 - 1.0] noise factor for hair width noise 
	gfsdk_F32		m_widthRootScale;			//!< [0 - 1.0] scale factor for top side of the strand
	gfsdk_F32		m_widthTipScale;			//!< [0 - 1.0] scale factor for bottom side of the strand

	gfsdk_F32		m_clumpNoise;				//!< [0 - 1.0] probability of each hair gets clumped (0 = all hairs get clumped, 1 = clump scale is randomly distributed from 0 to 1)
	gfsdk_F32		m_clumpRoundness;			//!< [0 - 2.0] exponential factor to control roundness of clump shape (0 = linear cone, clump scale *= power(t, roundness), where t is normalized distance from the root)
	gfsdk_F32		m_clumpScale;				//!< [0 - 1.0] how clumped each hair face is

	gfsdk_F32		m_density;					//!< [0 -    ] hair density per face (1.0 = 64 hairs per face)
	gfsdk_bool		m_usePixelDensity;			//!< [true/false] whether to use per-pixel sampling or per-vertex sampling for density map

	gfsdk_F32		m_lengthNoise;				//!< [0 - 1.0] length variation noise
	gfsdk_F32		m_lengthScale;				//!< [0 - 1.0] length control for growing hair effect

	gfsdk_F32		m_waveScale;				//!< [In Centimeters] size of waves for hair waviness 
	gfsdk_F32		m_waveScaleNoise;			//!< [0 - 1.0] noise factor for the wave scale
	gfsdk_F32		m_waveScaleClump;			//!< [0 - 1.0] waviness at clump level
	gfsdk_F32		m_waveScaleStrand;			//!< [0 - 1.0] waviness at strand level
	gfsdk_F32		m_waveFreq;					//!< [0 -    ] wave frequency (1.0 = one sine wave along hair length)
	gfsdk_F32		m_waveFreqNoise;			//!< [0 - 1.0] noise factor for the wave frequency 
	gfsdk_F32		m_waveRootStraighten;		//!< [0 - 1.0] For some distance from the root, we attenuate waviness so that root itself does not move [0-1]

	/// shading controls
	gfsdk_F32		m_rootAlphaFalloff;			//!< [0 - 1.0] falloff factor for alpha transition from root 
	gfsdk_float4	m_rootColor;				//!< [0 - 1.0] color of hair root (when hair textures are not used)
	gfsdk_float4	m_tipColor;					//!< [0 - 1.0] color of hair tip (when hair textures are not used)
	gfsdk_F32		m_rootTipColorWeight;		//!< [0 - 1.0] blend factor between root and tip color in addition to hair length
	gfsdk_F32		m_rootTipColorFalloff;		//!< [0 - 1.0] falloff factor for root/tip color interpolation

	gfsdk_F32		m_diffuseBlend;				//!< [0 - 1.0] blend factor between Kajiya hair lighting vs normal skin lighting.
	gfsdk_F32		m_hairNormalWeight;			//!< [0 - 1.0] blend factor between mesh normal vs hair normal. Use higher value for longer (surface like) hair.
	gfsdk_U32		m_hairNormalBoneIndex;		//!< [0 - number of bones] index for the bone which we use as model center for diffuse shading purpose

	gfsdk_float4	m_specularColor;			//!< [0 - 1.0] specular color
	gfsdk_F32		m_specularNoiseScale;		//!< [0 - 1.0] amount of specular noise
	gfsdk_F32		m_specularEnvScale;			//!< [0 - 1.0] amount of specular scale from env probe
	gfsdk_F32		m_specularPrimary;			//!< [0 - 1.0] primary specular factor
	gfsdk_F32		m_specularPowerPrimary;		//!< [0 - ] primary specular power exponent
	gfsdk_F32		m_specularPrimaryBreakup;	//!< [0 - 1.0] shift factor to make specular highlight move with noise
	gfsdk_F32		m_specularSecondary;		//!< [0 - 1.0] secondary specular factor
	gfsdk_F32		m_specularSecondaryOffset;	//!< [0 - 1.0] secondary highlight shift offset along tangents
	gfsdk_F32		m_specularPowerSecondary;	//!< [0 - ] secondary specular power exponent		

	gfsdk_F32		m_glintStrength;			//!< [0 - 1.0] strength of the glint noise
	gfsdk_F32		m_glintCount;				//!< [0 - 1024] number of glint sparklers along each hair
	gfsdk_F32		m_glintExponent;			//!< [0 - ] glint power exponent

	gfsdk_bool		m_castShadows;				//!< [true/false] this hair cast shadows onto the scene
	gfsdk_bool		m_receiveShadows;			//!< [true/false] this hair receives shadows from the scene
	gfsdk_F32		m_shadowSigma;				//!< [In Centimeters] distance through hair volume beyond which hairs get completely shadowed.

	gfsdk_U32		m_strandBlendMode;			//!< [GFSDK_HAIR_STRAND_BLEND_MODE] blend mode when strand texture is used. Supported mode are defined in GFSDK_HAIR_STRAND_BLEND_MODE.
	gfsdk_F32		m_strandBlendScale;			//!< [0 - 1.0] scale strand texture before blend

	// simulation control
	gfsdk_F32		m_backStopRadius;			//!< [0 - 1.0] radius of backstop collision (normalized along hair length)
	gfsdk_F32		m_bendStiffness;			//!< [0 - 1.0] stiffness for bending, useful for long hair
	gfsdk_F32		m_damping;					//!< [0 - ] damping to slow down hair motion
	gfsdk_float3	m_gravityDir;				//!< [0 - 1.0] gravity force direction (unit vector)
	gfsdk_F32		m_friction;					//!< [0 - 1.0] friction when capsule collision is used
	gfsdk_F32		m_massScale;				//!< [In Meters] mass scale for this hair
	gfsdk_F32		m_inertiaScale;				//!< [0 - 1.0] inertia control. (0: no inertia, 1: full inertia)
	gfsdk_F32		m_inertiaLimit;				//!< [In Meters] speed limit where everything gets locked (for teleport etc.)
	gfsdk_F32		m_interactionStiffness;		//!< [0 - 1.0] how strong the hair interaction force is
	gfsdk_F32		m_rootStiffness;			//!< [0 - 1.0] attenuation of stiffness away from the root (stiffer at root, weaker toward tip)
	gfsdk_F32		m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	gfsdk_bool		m_simulate;					//!< [true/false] whether to turn on/off simulation
	gfsdk_F32		m_stiffness;				//!< [0 - 1.0] how close hairs try to stay within skinned position
	gfsdk_F32		m_stiffnessStrength;		//!< [0 - 1.0] how strongly hairs move toward the stiffness target
	gfsdk_F32		m_stiffnessDamping;			//!< [0 - 1.0] how fast hair stiffness generated motion decays over time
	gfsdk_F32		m_tipStiffness;				//!< [0 - 1.0] attenuation of stiffness away from the tip (stiffer at tip, weaker toward root)
	gfsdk_bool		m_useCollision;				//!< [true/false] whether to use the sphere/capsule collision or not for hair/body collision
	gfsdk_float3	m_wind;						//!< [In Meters] vector force for main wind direction
	gfsdk_F32		m_windNoise;				//!< [0 - 1.0] strength of wind noise

	gfsdk_float4	m_stiffnessCurve;			//! [0 - 1.0] curve values for stiffness 
	gfsdk_float4	m_stiffnessStrengthCurve;	//! [0 - 1.0] curve values for stiffness strength
	gfsdk_float4	m_stiffnessDampingCurve;	//! [0 - 1.0] curve values for stiffness damping
	gfsdk_float4	m_bendStiffnessCurve;		//! [0 - 1.0] curve values for bend stiffness
	gfsdk_float4	m_interactionStiffnessCurve;//! [0 - 1.0] curve values for interaction stiffness

	// lod controls
	gfsdk_bool		m_enableLOD;				//!< [true/false] whether to enable/disable entire lod scheme

	gfsdk_bool		m_enableDistanceLOD;		//!< [true/false] whether to enable lod for far away object (distance LOD)
	gfsdk_F32		m_distanceLODStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start fading out (by reducing density)
	gfsdk_F32		m_distanceLODEnd;			//!< [In Meters] distance (in scene unit) to camera where fur will completely disappear (and stop simulating)
	gfsdk_F32		m_distanceLODFadeStart;		//!< [In Meters] distance (in scene unit) to camera where fur will fade with alpha from 1 (this distance) to 0 (DistanceLODEnd)
	gfsdk_F32		m_distanceLODDensity;		//!< [0 - ] density when distance LOD is in action.  hairDensity gets scaled based on LOD factor.
	gfsdk_F32		m_distanceLODWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	gfsdk_bool		m_enableDetailLOD;			//!< [true/false] whether to enable lod for close object (detail LOD)
	gfsdk_F32		m_detailLODStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start getting denser toward closeup density
	gfsdk_F32		m_detailLODEnd;				//!< [In Meters] distance (in scene unit) to camera where fur will get full closeup density value
	gfsdk_F32		m_detailLODDensity;			//!< [0 - ] density scale when closeup LOD is in action.  hairDensity gets scaled based on LOD factor.
	gfsdk_F32		m_detailLODWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	gfsdk_F32		m_shadowDensityScale;		//!< [0 - 1] density scale factor to reduce hair density for shadow map rendering

	gfsdk_bool		m_useViewfrustrumCulling;	//!< [true/false] when this is on, density for hairs outside view are set to 0. Use this option when fur is in a closeup.
	gfsdk_bool		m_useBackfaceCulling;		//!< [true/false] when this is on, density for hairs growing from backfacing faces will be set to 0
	gfsdk_F32		m_backfaceCullingThreshold; //!< [-1 - 1.0] threshold to determine backface, note that this value should be slightly smaller 0 to avoid hairs at the silhouette from disappearing

	gfsdk_bool		m_useCullSphere;			//!< [true/false] when this is on, hairs get culled when their root points are inside the sphere
	gfsdk_float4x4	m_cullSphereInvTransform;	//!< inverse of general affine transform (scale, rotation, translation..) applied to a unit sphere centered at origin

	gfsdk_U32		m_splineMultiplier;			//!< how many vertices are generated per each control hair segments in spline curves

	// drawing option
	gfsdk_bool		m_drawRenderHairs;			//!< [true/false] draw render hair
	gfsdk_bool		m_visualizeBones;			//!< [true/false] visualize skinning bones
	gfsdk_bool		m_visualizeBoundingBox;		//!< [true/false] draw bounding box of hairs
	gfsdk_bool		m_visualizeCapsules;		//!< [true/false] visualize collision capsules
	gfsdk_bool		m_visualizeControlVertices; //!< [true/false] draw control vertices of guide hairs
	gfsdk_bool		m_visualizeCullSphere;		//!< [true/false] draw cull sphere
	gfsdk_bool		m_visualizeFrames;			//!< [true/false] visualize coordinate frames
	gfsdk_bool		m_visualizeGrowthMesh;		//!< [true/false] draw growth mesh
	gfsdk_bool		m_visualizeGuideHairs;		//!< [true/false] draw guide hairs
	gfsdk_bool		m_visualizeHairInteractions;//!< [true/false] draw hair interaction lines
	gfsdk_U32		m_visualizeHairSkips;		//!< [0 - ] for per hair visualization, how many hairs to skip?
	gfsdk_bool		m_visualizeLocalPos;		//!< [true/false] visualize target pose for bending
	gfsdk_bool		m_visualizePinConstraints;	//!< [true/false] whether to visualize pin constraint spheres
	gfsdk_bool		m_visualizeShadingNormals;	//!< [true/false] visualize normals used for hair shading
	gfsdk_bool		m_visualizeShadingNormalBone;	//!< [true/false] visualize bone used as shading normal center
	gfsdk_bool		m_visualizeSkinnedGuideHairs; //!< [true/false] draw skinned positions for guide hairs

	gfsdk_U32		m_colorizeMode;				//!< [GFSDK_HAIR_COLORIZE_MODE] colorize hair based on various terms. See GFSDK_HAIR_COLORIZE_MODE.
	
	// texture control
	GFSDK_HAIR_TEXTURE_CHANNEL m_textureChannels[GFSDK_HAIR_NUM_TEXTURES]; //!< texture channel for each control textures.  
	
	// model to world transform
	gfsdk_float4x4	m_modelToWorld;				// render time transformation to offset hair from its simulated position

	// default values
	GFSDK_HairInstanceDescriptor() :

		m_enable(true),

		// default geometry parameters
		m_width(1.0f),
		m_widthNoise(0.0f),
		m_widthRootScale(1.0f),
		m_widthTipScale(0.1f),

		m_clumpNoise(0.0f),
		m_clumpRoundness(1.0f),
		m_clumpScale(0.0f),
		
		m_density(1.0f), 
		m_lengthNoise(1.0f),
		m_lengthScale(1.0f),
			
		m_usePixelDensity(false),
		m_waveScale(0.0f),
		m_waveScaleClump(0.0f),
		m_waveScaleStrand(1.0f),
		m_waveScaleNoise(0.5f),
		m_waveFreq(3.0f),
		m_waveFreqNoise(0.5f),
		m_waveRootStraighten(0.0f),

		// default shading parameters
		m_diffuseBlend(0.5f),
		m_hairNormalWeight(0.0f),
		m_hairNormalBoneIndex(gfsdk_U32(-1)),

		m_glintStrength(0.0f),
		m_glintCount(256.0f),
		m_glintExponent(2.0f),
		m_rootTipColorWeight(0.5f),
		m_rootTipColorFalloff(1.0f),

		m_specularNoiseScale(0.0f),
		m_specularEnvScale(0.25f),
		m_specularPrimary(0.1f),
		m_specularPrimaryBreakup(0.0f),
		m_specularSecondary(0.05f),
		m_specularSecondaryOffset(0.1f),
		m_specularPowerPrimary(100.0f),
		m_specularPowerSecondary(20.0f),

		m_rootAlphaFalloff(0.0f),

		m_shadowSigma(0.2f),
		m_castShadows(true),
		m_receiveShadows(true),

		m_strandBlendMode(GFSDK_HAIR_STRAND_BLEND_OVERWRITE),
		m_strandBlendScale(1.0f),

		// default simulation parameters
		m_simulate(true),
		m_backStopRadius(0.0f),
		m_bendStiffness(0.0f),
		m_damping(0.0f),
		m_friction(0.0f),
		m_inertiaScale(1.0f),
		m_inertiaLimit(1000.0f),
		m_interactionStiffness(0.0f),
		m_massScale(10.0f),
		m_windNoise(0.0f),
		m_stiffness(0.5f),
		m_stiffnessStrength(1.0f),
		m_stiffnessDamping(0.0f),
		m_rootStiffness(0.5f),
		m_pinStiffness(1.0f),
		m_tipStiffness(0.0f),
		m_useCollision(false),

		// default LOD parameters
		m_enableLOD(false),

		m_enableDistanceLOD(true),
		m_distanceLODStart(5.0f), 
		m_distanceLODEnd(10.0f), 
		m_distanceLODFadeStart(1000.0f),
		m_distanceLODDensity(0.0f),
		m_distanceLODWidth(1.0f),

		m_enableDetailLOD(true),
		m_detailLODStart(2.0f), 
		m_detailLODEnd(1.0f), 
		m_detailLODDensity(1.0f),
		m_detailLODWidth(1.0f),

		m_shadowDensityScale(0.5f),

		m_useViewfrustrumCulling(true),
		m_useBackfaceCulling(false),
		m_backfaceCullingThreshold(-0.2f),
		m_useCullSphere(false),

		m_splineMultiplier(4),

		// visualization options
		m_drawRenderHairs(true),		
		m_visualizeBones(false),
		m_visualizePinConstraints(false),
		m_visualizeCapsules(false),
		m_visualizeGrowthMesh(false),	
		m_visualizeGuideHairs(false),	
		m_visualizeControlVertices(false),
		m_visualizeBoundingBox(false),
		m_visualizeCullSphere(false),
		m_visualizeShadingNormalBone(false),
		m_visualizeHairInteractions(false),
		m_visualizeSkinnedGuideHairs(false),	
		m_visualizeFrames(false),
		m_visualizeLocalPos(false),
		m_visualizeShadingNormals(false),
		m_visualizeHairSkips(0),

		m_colorizeMode(GFSDK_HAIR_COLORIZE_MODE_NONE)

		{
			m_gravityDir.x = 0.0f; 
			m_gravityDir.y = 0.0f; 
			m_gravityDir.z = -1.0f;

			m_wind.x = 0.0f; 
			m_wind.y = 0.0f; 
			m_wind.z = 0.0f;

			m_rootColor.x = 1.0f; m_rootColor.y = 1.0f; m_rootColor.z = 1.0f; m_rootColor.w = 1.0f;
			m_tipColor.x = 1.0f; m_tipColor.y = 1.0f; m_tipColor.z = 1.0f; m_tipColor.w = 1.0f;
			m_specularColor.x = 1.0f; m_specularColor.y = 1.0f; m_specularColor.z = 1.0f; m_specularColor.w = 1.0f;

#define MAKE_IDENTITY(M) M._11 = 1.0f; M._12 = 0.0f; M._13 = 0.0f; M._14 = 0.0f; \
			M._21 = 0.0f; M._22 = 1.0f; M._23 = 0.0f; M._24 = 0.0f; \
			M._31 = 0.0f; M._32 = 0.0f; M._33 = 1.0f; M._34 = 0.0f; \
			M._41 = 0.0f; M._42 = 0.0f; M._43 = 0.0f; M._44 = 1.0f;

			MAKE_IDENTITY(m_modelToWorld);

			MAKE_IDENTITY(m_cullSphereInvTransform);

#undef MAKE_IDENTITY

#define SETX(X, V) X.x = V; X.y = V; X.z = V; X.w = V;

			SETX(m_stiffnessCurve, 1.0f);
			SETX(m_stiffnessStrengthCurve, 1.0f);
			SETX(m_stiffnessDampingCurve, 1.0f);
			SETX(m_bendStiffnessCurve, 1.0f);
			SETX(m_interactionStiffnessCurve, 1.0f);
#undef SETX

			for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
				m_textureChannels[i] = GFSDK_HAIR_TEXTURE_CHANNEL_RED;
		}
};

/**
	\brief statistics for optimization and profiling
	\details For statistics or profiling purpose, one can query the HairSDK how much resources are currently consumed.
	\see Use HairSDK.ComputeStats() to retrieve this data.
*/
struct GFSDK_HairStats
{
	gfsdk_S32	m_numHairs;					//!< total hair counts for the hair instances
	gfsdk_S32	m_numFaces;					//!< total face counts for the hair instance
	gfsdk_F32	m_averageCV;				//!< average CV per hair
	gfsdk_F32	m_averageDensity;			//!< average density, accouting for density maps, etc.
	gfsdk_F32	m_averageHairsPerFace;		//!< average hairs per face

	gfsdk_F32	m_distanceLODFactor;		//!< distance LOD factor
	gfsdk_F32	m_detailLODFactor;			//!< closeup LOD factor
	gfsdk_F32	m_camDistance;				//!< distance to camera

public:
	GFSDK_HairStats() :
		m_numHairs(0),
		m_numFaces(0),

		m_averageCV(0.0f),
		m_averageDensity(0.0f),
		m_averageHairsPerFace(0.0f),

		m_distanceLODFactor(0.0f),
		m_detailLODFactor(0.0f),
		m_camDistance(0.0f)

		{}
};

/**
	\brief Data structure used to customize HairWorks shader settings.
	\details Users can customize HairWorks runtime by providing their render settings with this structure.
	\see GFSDK_HairSDK.RenderHairs()
*/
struct GFSDK_HairShaderSettings
{
	gfsdk_bool	m_useCustomConstantBuffer;	//!< If true, HairWorks will not bind constant bufer
	gfsdk_bool	m_shadowPass;				//!< If true, density and width will be adjusted based on m_shadowDensityScale of GFSDK_HairInstanceDescriptor

public:
	GFSDK_HairShaderSettings(
		gfsdk_bool	useCustomConstantBuffer		= false,
		gfsdk_bool	shadowPass					= false
		) 
	{
		m_useCustomConstantBuffer	= useCustomConstantBuffer;
		m_shadowPass				= shadowPass;
	}
};

/**
	\brief shader cache settings to create optimized shader per each hair asset.
	\details By giving hints about which features are used, HairWorks can build optimized shader before runtime.
			 Note that once an option is disabled in shader cache, the feature will not work even if it is enabled in instance descriptor in runtime.
	\see GFSDK_HairSDK.AddToShaderCache() to add optimized shader.
*/
struct GFSDK_HairShaderCacheSettings
{
	bool		useCullSphere;		//!< if cull sphere is used (GFSDK_HairInstanceDescriptor.m_useCullSphere == true)
	bool		useClumping;		//!< if clumping is used (GFSDK_HairInstanceDescriptor.m_clumpScale > 0)
	bool		useWaveStrand;		//!< if strand waviness is used (GFSDK_HairInstanceDescriptor.m_waveScale > 0 && GFSDK_HairInstanceDescriptor.m_waveStrand > 0)
	bool		useWaveClump;		//!< if strand waviness is used (GFSDK_HairInstanceDescriptor.m_waveScale > 0 && GFSDK_HairInstanceDescriptor.m_waveClump > 0)
	bool		usePixelDensity;	//!< if per-pixel density option is used (GFSDK_HairInstanceDescriptor.m_usePixelDeisnty = true)

	bool		isTextureUsed[GFSDK_HAIR_NUM_TEXTURES]; //!< flag to tell if control texture is used.  
	GFSDK_HAIR_TEXTURE_CHANNEL	textureChannel[GFSDK_HAIR_NUM_TEXTURES]; //!< texture channels 

	// default option is to turn on all the options
	GFSDK_HairShaderCacheSettings()
	{
		useCullSphere				=	true;
		useClumping					=	true;
		useWaveStrand				=	true;
		useWaveClump				=	true;
		usePixelDensity				=	true;

		for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
			isTextureUsed[i] = true;

		for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
			textureChannel[i] = GFSDK_HAIR_TEXTURE_CHANNEL_RED; // red channel
	}

	// set feature sets from instance descriptor.
	// Note that texture references are not part of instance descriptor, so still need to be set after this function.
	void SetFromInstanceDescriptor(const GFSDK_HairInstanceDescriptor &desc)
	{
		usePixelDensity = desc.m_usePixelDensity;
		useCullSphere	= desc.m_useCullSphere;

		useClumping	= desc.m_clumpScale > 0.0f;
		useWaveStrand = (desc.m_waveScale > 0.0f) && (desc.m_waveScaleStrand > 0.0f);
		useWaveClump = (desc.m_waveScale > 0.0f) && (desc.m_waveScaleClump > 0.0f);

		for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
			textureChannel[i] = desc.m_textureChannels[i]; //!< texture chanel for each control textures.  
	}
};

/**
	\brief Constant buffer structure to map hair shading data to DX constant buffer
	\see Use GFSDK_HairSDK.PrepareShaderConstantBuffer() to get this data structure properly mapped for shader use.
*/

struct GFSDK_HairShaderConstantBuffer
{
	#define GFSDK_HAIR_CONSTANT_BUFFER_SIZE 1280 // = 1024 + 256 constant buffer size used by HairWorks pixel shader.
	float m_data[GFSDK_HAIR_CONSTANT_BUFFER_SIZE]; 
};

/**
	\brief Settings to apply coordinate/unit conversion for hair asset loading.
	\details When hair asset is exported from various DCC tools, needs may arise to properly convert unit and coordinate system settings to match
		different setups in game engines. Use the following data structure to provide information about how HairWorks should convert those.
	\note The axis conversion uses data stored in GFSDK_HairAssetDescriptor (m_upAxis, m_handedness).
		If any of the data is set to unknown (0), or if any of target hint is unknown, we do not perform any default conversion.
	\note If m_pConversionMatrix is set to non-null, this overrides standard conversion and we multiply this matrix as follows
		For all position data (hair vertices, etc.)
			p_converted = p_old * m_pConversionMatrix
		For all matrix data (bind pose matrix, etc.)
			M_converted = M_old * m_pConversionMatrix.
*/
struct GFSDK_HairConversionSettings
{
	GFSDK_HAIR_UP_AXIS_HINT			m_targetUpAxisHint;			//!< up axis used by the game engine that will use this asset in runtime
	GFSDK_HAIR_HANDEDNESS_HINT		m_targetHandednessHint;		//!< handedness of original tools that generated this asset
	gfsdk_float4x4*					m_pConversionMatrix;		//!< If not null, we use this conversion matrix instead
	gfsdk_F32						m_targetSceneUnit;			//!< scene unit (in centimeters) for game engine.  0 means unknown (use source unit)
																// Centimeter (default): 1.0.
																// Meter: 100.0 
																// Inch: 2.54
																// Decimeter: 10.0
public:
	GFSDK_HairConversionSettings() :
		m_targetUpAxisHint(GFSDK_HAIR_UP_AXIS_UNKNOWN),
		m_targetHandednessHint(GFSDK_HAIR_HANDEDNESS_UNKNOWN),
		m_pConversionMatrix(0),
		m_targetSceneUnit(0.0f)
	{
	}
};
/**
	\brief This abstract class provides all the API for HairWorks runtime
*/
class GFSDK_HairSDK
{
public:
	/*=============================================================================================
		OVERVIEW

		To use HairWorks runtime, we first need to load the HairWorks dll and create this HairSDK object.
		See LoadHairSDK(gfsdk_cstr dllPath, gfsdk_U32 version = GFSDK_HAIRWORKS_VERSION) at the end of this header.
		Once SDK's DLL is loaded, we can use the HairSDK object to access all the APIs below.
		When HairSDK is not needed (typically at the shutdown stage of a game), call Release().
	=============================================================================================*/

	/*
		\brief Deletes this SDK object.
	*/
	virtual void Release(void) = 0;

	/*=============================================================================================
		HAIR ASSET PREPARATION AND MANAGEMENT

		The first step is to get hair asset created and loaded, and get hair asset ID.
		The hair assets can be either created manually or loaded from a file (.apx/.apb).
		
		See functions below.
	=============================================================================================*/

	/**
		\brief loads hair asset data from descriptor. 
		\param [in] assetDesc The hair asset descriptor created from apx file, etc.
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value.
		\return GFSDK_RETURN_OK is returned when hair asset is loaded successfully.
	*/
	virtual GFSDK_HAIR_RETURNCODES CreateHairAsset(const GFSDK_HairAssetDescriptor& assetDesc, GFSDK_HairAssetID *assetID) = 0;

	/**
		\brief destroy/release hair asset data
		\param [in] assetID hair asset ID to delete
		\return GFSDK_RETURN_OK is returned when hair asset was successfully destroyed.
	*/
	virtual GFSDK_HAIR_RETURNCODES FreeHairAsset( const GFSDK_HairAssetID assetID ) = 0;

	/**
		\brief load hair asset data from an (.apx/.apb) file
		\param [in] filename File name for a valid .apx or .apb file that stores hair asset descriptor and instance descriptor, texture file references
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value. assetID must be not NULL.
		\param [out] info If the info is not null, the info is filled upon success.
		\param [in] pSettings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See GFSDK_HairConversionSettings.
	
		\return GFSDK_HAIR_RETURN_OK is returned if file read was successful.
				GFSDK_HAIR_RETURN_OPEN_FAILED is returned if file not found or open failed.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if the assetID is NULL.
				GFSDK_HAIR_RETURN_INVALID_FORMAT is returned if the file format is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadHairAssetFromFile(
		gfsdk_cstr							filename, 
		GFSDK_HairAssetID*					assetID, 
		GFSDK_HairWorksInfo*				info = 0, 
		const GFSDK_HairConversionSettings*	pSettings = 0) = 0;

	/**
		\brief load hair asset data from a memory buffer that contains (.apx/.apb) file content
		\param [in] pMemoryBuffer Pointer to the memory buffer that contains a valid .apx or .apb file content.
		\param [in] memoryBufferSizeBytes Size of the memory buffer in bytes.
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value.
		\param [out] info If the info is not null, the info is filled upon success.
		\param [in] pSettings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See GFSDK_HairConversionSettings.
	
		\return GFSDK_HAIR_RETURN_OK is returned if file read was successful.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if the assetID is NULL.
				GFSDK_HAIR_RETURN_INVALID_FORMAT is returned if the memory format is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadHairAssetFromMemory(
		const void*							pMemoryBuffer, 
		gfsdk_U32							memoryBufferSizeBytes, 
		GFSDK_HairAssetID*					assetID, 
		GFSDK_HairWorksInfo*				info = 0, 
		const GFSDK_HairConversionSettings* pSettings = 0) = 0;

	/**
		\brief save hair asset data to an (.apx/.apb) file
		\param [in] filename File name for a .apx or .apb file to store hair asset descriptor and instance descriptor, texture files.
		\param [in] assetID hair asset ID to store.
		\param [in] pInstanceDescriptor Instance descriptor to save in apx file.  If this is NULL, default instance descriptor for the asset will be saved.
		\param [in] pInfo file header info to be stored. info can be NULL.
		\param [in] pTextureNames Set texture file names if different from the names in the original asset. If NULL, texture file names loaded from original asset will be saved.

		\return GFSDK_HAIR_RETURN_OK is returned if file write was successful.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if the assetID is not valid.
				GFSDK_HAIR_RETURN_OPEN_FAILED is returned if file open failed. filename with not ".apx" or ".apb" will also return this.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveHairAssetToFile(
		gfsdk_cstr							filename, 
		const GFSDK_HairAssetID				assetID, 
		const GFSDK_HairInstanceDescriptor* pInstanceDescriptor = 0, 
		const GFSDK_HairWorksInfo*			pInfo = 0,
		const gfsdk_cstr*					pTextureNames = 0) = 0;

	virtual GFSDK_HAIR_RETURNCODES SaveHairAssetToMemory(
		void*& memory,
		unsigned& memorySize,
		gfsdk_new_delete_t* allocator,	// Must not be null if no custom allocator is passed to GFSDK_LoadHairSDK()
		bool binary,
		const GFSDK_HairAssetID				assetID,
		const GFSDK_HairInstanceDescriptor* pInstanceDescriptor = 0,
		const GFSDK_HairWorksInfo*			pInfo = 0,
		const gfsdk_cstr*					pTextureNames = 0) = 0;

	/**
		\brief save hair instance data to an (.apx/.apb) file
		\param [in] filename File name for a .apx or .apb file to store hair asset descriptor and instance descriptor, texture files.
		\param [in] instnaceID hair instance ID to save.
		\param [in] pInfo file header info to be stored. info can be NULL.
		\param [in] pTextureNames Set texture file names if different from the names in the original asset. If NULL, texture file names loaded from original asset will be saved.
		\return GFSDK_RETURN_OK is returned if file write was successful.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveHairInstanceToFile(
		gfsdk_cstr							filename, 
		const GFSDK_HairInstanceID			instanceID, 
		const GFSDK_HairWorksInfo*			pInfo = 0,
		const gfsdk_cstr*					pTextureNames = 0) = 0;

	/**
		\brief copy some parts of assets from one asset to another
		\param[in] fromAssetID asset id to copy property from
		\param[in] toAssetID asset id to copy property to
		\note Useful for importing certain part of asset data.  fromAssetID and toAssetID cannot be the same.
		\return GFSDK_RETURN_OK is returned if copy operation was successful.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyAsset(
		const GFSDK_HairAssetID		fromAssetID, 
		const GFSDK_HairAssetID		toAssetID,
		GFSDK_HairAssetCopySettings settings = GFSDK_HairAssetCopySettings()
		) = 0;

	/**
		\brief Get hair default instance descriptor from the asset.
		\param [in] hairAssetID hair asset id that holds the default instance descriptor
		\param [inout] descriptor Hair instance descriptor to copy the data to.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyInstanceDescriptorFromAsset(
		const GFSDK_HairAssetID			hairAssetID, 
		GFSDK_HairInstanceDescriptor&	descriptor
		) = 0;

	/**
		\brief resample number of cvs to target number
		\param[in] assetID asset identifier to resample
		\param[in] targetNbPointsPerHair number of cvs for each hair
		\return GFSDK_RETURN_OK is returned if resampling was successful.
	*/
	virtual GFSDK_HAIR_RETURNCODES ResampleGuideHairs(
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U16					targetNbPointsPerHair
		) = 0;

	/*=============================================================================================
		HAIR SHADER CACHE MANAGEMENT

		HairWorks provides options to create optimized shader for each specific asset.
		By removing unused features, performance can be significantly improved. 
		This 'cooking' process can be performed before game runs and does not require D3D device or context.
		This process can be done as preprocess once all the assets are locked for game release.

		Use the following functions to create, store, and load optimized shader caches.
		NOTE: If shader cache is not defined, HairWorks will run in unoptimized mode.

	=============================================================================================*/
	/**
		\brief clear entire shader cache database
		\details call this function in the beginning of shader cache cooking process.
		\return GFSDK_RETURN_OK is returned if cache was properly initialized and cleared.
	*/
	virtual GFSDK_HAIR_RETURNCODES ClearShaderCache(
		) = 0;

	/**
		\brief add new shader cache based on specified shader settings
		\details add shader to the cache with specified settings
		\param[in] settings flags that affect shader cache generation.  If matching shader already exists, this will be skipped.
		\return GFSDK_RETURN_OK is returned if cache was added or it already exists.
	*/
	virtual GFSDK_HAIR_RETURNCODES AddToShaderCache(
		const GFSDK_HairShaderCacheSettings& settings
		) = 0;

	/**
		\brief Save serialized shader cache data to given memory buffer.
		\details Once caches has been added, use this function to get serialized cache buffer. Users can write this data to their own file format for future use.
		\param[out] ppMemoryBuffer Cache buffer will be allocated using HairWorks allocator, and will be filled with cache data.
		\param[out] memoryBufferSizeBytes size of cache buffer is returned.
		\return GFSDK_RETURN_OK is returned if cache was properly serialized.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveShaderCacheToMemory(
		void**		ppMemoryBuffer, 
		size_t&		memoryBufferSizeBytes
	) = 0;

	/*=============================================================================================
		RENDERER INITIALIZATION

		Once the game starts running and DX device is prepared, we should call InitRenderResources() once for HairSDK to 
		consequently manage internal DX resources.
	=============================================================================================*/

	/**
		\breif Initialize DX11 device and internal render state variables and shaders
		\param [in] pd3dDevice The DX11 device that HairWorks should use to create all the DX11 resources
		\param [in] pd3dContext When d3d context is known at time of calling this function, set it here. If not use SetCurrentContext() later.
					
		\return GFSDK_HAIR_RETURN_OK is returned when rendering resources has been successfully initialized.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES InitRenderResources( 
		ID3D11Device*			pd3dDevice, 
		ID3D11DeviceContext*	pd3dContext= 0
		) = 0;

	/**
		\brief Load previously cooked shader cache.
		\details This fills internal shader cache from serialized data that was generated by SaveShaderCacheToMemory() function calls.
		\return GFSDK_RETURN_OK is returned if cache data is valid and shader caches were properly initialized.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadShaderCacheFromMemory(
		const void*	pMemoryBuffer
	) = 0;

	/**
		\brief Clean up all the internally used DX11 resources.
		\return GFSDK_HAIR_RETURN_OK is returned when rendering resources has been successfully cleaned up.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual void				FreeRenderResources() = 0;

	/**
		\brief set current D3D context. 
		\detail All subsequent hairworks calls will use this context for simulation and rendering
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetCurrentContext(
		ID3D11DeviceContext*	pd3dContext
		) = 0;

	/*=============================================================================================
		HAIR INSTANCE MANAGEMENT

		Given properly initialized HairSDK object and hair asset ID, we can now instantiate an actual 
		hair instance object anytime during the game play, allowing hair creatures to be dynamically 
		spawned/deleted on the fly.
		All the control parameters defined in the GFSDK_HairInstanceDescriptor can be updated anytime.
		Control textures for the parameters can be set either using D3D SRV, 
		and these can be set anytime once hair instance has been created.
	=============================================================================================*/

	/**
		\brief Create a hair instance from given asset type
		\param [in] hairAssetID hair asset type to create a hair instance from.  
					The assetID should have been generated from a successful call of HairSDK.LoadHairAsset().
		\param [out] newInstanceID If a hair instance was successfully created, an ID value is written to this variable.

		\return GFSDK_HAIR_RETURN_OK is returned when the new hair instance was successfully created.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned when the hairAssetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES CreateHairInstance( 
		const GFSDK_HairAssetID		hairAssetID, 
		GFSDK_HairInstanceID*		newInstanceID
		) = 0;

	/**
		\brief Delete a given hair instance
		\param [in] hairInstanceID hair instance to delete

		\return GFSDK_HAIR_RETURN_OK is returned when the hair instance was successfully destroyed.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned when the hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES FreeHairInstance( 
		const GFSDK_HairInstanceID	hairInstanceID 
		) = 0;

	/**
		\brief Get currently used instance descriptor for the chosen hair instance 
		\param [in] hairInstanceID hair instance id to get the instance descriptor
		\param [inout] descriptor Hair instance descriptor to copy the data to.

		\return GFSDK_HAIR_RETURN_OK is returned if the default instance descriptor was successfully copied.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyCurrentInstanceDescriptor(
		const GFSDK_HairInstanceID		hairInstanceID, 
		GFSDK_HairInstanceDescriptor&	descriptor) = 0; 

	/**
		\brief Update hair instance parameters
		\details One can change rendering/simulation parameters by updating hair instance descriptor.  
					This can be called at any time during runtime, but typically called before 
					either HairSDK.RenderHairs() or HairSDK.StepSimulation() calls.
		\param [in] hairInstanceID hair instance to update.
		\param [in] descriptor hair instance descriptor to update.
		\param [in] [optional] which material set to update when there are multiple material sets

		\return GFSDK_HAIR_RETURN_OK is returned when the hair instance parameters were successfully updated.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateInstanceDescriptor( 
		const GFSDK_HairInstanceID				hairInstanceID, 
		const GFSDK_HairInstanceDescriptor&		descriptor) = 0;

	/**
		\brief Set texture resource for control textures
		\param [in] hairInstanceID hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [in] pResource shader resource view created for the input texture, note texture resource should be managed by game itself.

		\return GFSDK_HAIR_RETURN_OK is returned when the hair control texture was successfully updated.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/ 
	virtual GFSDK_HAIR_RETURNCODES SetTextureSRV(
		const GFSDK_HairInstanceID			hairInstanceID, 
		const GFSDK_HAIR_TEXTURE_TYPE		textureType, 
		ID3D11ShaderResourceView*			pResource
		) = 0;

	/**
		\brief Get texture resource for control textures
		\param [in] hairInstanceID hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [out] ppResource shader resource view for stored control textures are copied, if available.  Otherwise NULL value will be written.

		\return GFSDK_HAIR_RETURN_OK is returned when the hair control texture was successfully updated.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note This function does not change reference counter for SRV. The returned pointer should not be stored for later use.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetTextureSRV(
		const GFSDK_HairInstanceID			hairInstanceID, 
		const GFSDK_HAIR_TEXTURE_TYPE		textureType, 
		ID3D11ShaderResourceView**			ppResource
		) = 0;

	/**
		\brief Get shader resource for attribute interpolation
		\detail Shader attributes such as tangent, normal, etc. can be mapped to custom pixel shader.
		    This function fills SRVs necessary for such mapping.  See sample codes.
		\param [in] hairInstanceID hair instance to get SRVs
		\param [out] ppResources array of SRVS, must have at least GFSDK_HAIR_NUM_SHADER_RESOUCES elements.
			The default resources filled are in following order:
			GFSDK_HAIR_SHADER_RESOUCE_HAIR_INDICES	: face to hair index buffer
			GFSDK_HAIR_SHADER_RESOUCE_TANGENTS		: hair tangent buffer
			GFSDK_HAIR_SHADER_RESOUCE_NORMALS		: hair normal buffer
		\see GetShaderSRV() to retrieve individual buffers.
			use GFSDK_HAIR_DECLARE_SHADER_RESOURCES() function in the shader to assign resource slot for each resource.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetShaderResources(
		const GFSDK_HairInstanceID				hairInstanceID, 
		ID3D11ShaderResourceView**				ppResources
		) = 0;

	/**
		\brief Get shader resource for attribute interpolation
		\detail Shader attributes such as tangent, normal, etc. can be mapped to custom pixel shader.
		    This function fills SRVs necessary for such mapping.  
		\param [in] hairInstanceID hair instance to get SRVs
		\param [in] resourceType type of resource requested.
		\param [out] ppResources corresponding resource's SRV is filled to this pointer.
			use GFSDK_HAIR_DECLARE_SHADER_RESOURCES() function in the shader to assign resource slot for each resource.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetShaderSRV(
		const GFSDK_HairInstanceID				hairInstanceID, 
		const GFSDK_HAIR_SHADER_RESOURCE_TYPE	resourceType, 
		ID3D11ShaderResourceView**				ppResource
		) = 0;

	/*=============================================================================================
		ANIMATION AND SIMULATION

		To move and animate hairs, a typical process is to give it an animation first, by updating 
		bones used to skin animated hair shapes.  The bone data can be either in the form of 
		standard linear matrices (HairSDK.UpdateSkinningMatrices) or dual quaternions (HairSDK.UpdateSkinninggfsdk_dualquaternions).
		Once skinning bones are set, we call HairSDK.StepSimulation() to further simulation motion of hairs for each frame.
		We allow maximum of 4 bones per each hair, see GFSDK_HairAssetDescriptor.m_pBoneIndices and GFSDK_HairAssetDescriptor.m_pBoneWeights.
	=============================================================================================*/

	/**
		\brief update skinning matrices by linear matrices
		\param [in] hairInstanceID hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the GFSDK_HairAssetDescriptor.
		\param [in] pSkinningMatrices array of linear skinning matrices
		\param [in] teleportMode teleport mode if any teleport option is used
		\return GFSDK_HAIR_RETURN_OK is returned when the hair skinning bones have been successfully updated.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note A skinning matrix is defined as world space bone transform applied after inverse transform of the bind pose of the bone.
			When only world space bone matrix is available, one can use GFSDK_HairAssetDescriptor.m_pBindPoses to get the bind pose, to construct the skinning matrix.
		\note The bone order should match the one defined in GFSDK_HairAssetDescriptor.m_pBoneNames.  
			The bone name can be also retrieved by GFSDK_HairSDK.GetBoneName() as well.  
			Make sure that the bone ordering is consistent between hair asset and characters used in the host application.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateSkinningMatrices( 
		const GFSDK_HairInstanceID	hairInstanceID, 
		const gfsdk_U32				numBones, 
		const gfsdk_float4x4*		pSkinningMatrices,
		GFSDK_HAIR_TELEPORT_MODE	teleportMode = GFSDK_HAIR_TELEPORT_MODE_NONE
		) = 0;

	/**
		\brief update skinning matrices by dual quaternions
		\param [in] hairInstanceID hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the GFSDK_HairAssetDescriptor.
		\param [in] pDQs array of dual quaternions.
		\param [in] teleportMode teleport mode if any teleport option is used
		\return GFSDK_HAIR_RETURN_OK is returned when the hair skinning info have been successfully updated.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateSkinningDQs( 
		const GFSDK_HairInstanceID	hairInstanceID, 
		const gfsdk_U32				numBones, 
		const gfsdk_dualquaternion *pDQs,
		GFSDK_HAIR_TELEPORT_MODE	teleportMode = GFSDK_HAIR_TELEPORT_MODE_NONE) = 0;

	/**
		\brief Runs simulation for all currently active hair instances for one frame.
		\details Compute GPU skinning for hair and run hair simulation for all the active hair instances.
		\param [in] pd3dContext D3D context where the simulation should happen.
		\param [in] timeStepSize simulation time step size in second for one frame.  Typically we sync with display fps (60).
		\param [in] worldReference This is useful when world containing hair itself is moving, but motion due to moving world is not desired and needs to be canceled out. 

		\return GFSDK_HAIR_RETURN_OK is returned when the hair simulation was successfully finished.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES StepSimulation( 
		gfsdk_F32				timeStepSize = 1.0f / 60.0f, 
		const gfsdk_float4x4*	worldReference = 0
		) = 0;

	/**
		\brief Returns a conservative bounds for hairs.
		\param [in] hairInstanceID hair instance to get the bounds information
		\param [inout] bbMin If not NULL, minimum bounds will be written here.
		\param [inout] bbMax If not NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return GFSDK_HAIR_RETURN_OK is returned when bounds computation was successfully finished.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note This function is intended for approximate, but fast culling purpose.
			This does not return exact bounds, but rather conservative bounds that are guaranteed to enclose all hairs regardless of current simulation/animation changes.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBounds( 
		const GFSDK_HairInstanceID		hairInstanceID, 
		gfsdk_float3*					bbMin, 
		gfsdk_float3*					bbMax, 
		bool							growthMeshOnly = false
		) = 0;

	/*=============================================================================================
		RENDERING HAIRS

		To render hairs, we first set global variables such as camera (HairSDK.SetViewProjection).
		For each hair instance, we then call HairSDK.RenderHairs() function to render hairs to current render target.
		\note RenderHairs() call requires users to provide and properly set shaders.  See accompanying sample codes.

	=============================================================================================*/
		
	/**
		\brief set camera projection matrices
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] FOV field of view in angles.
		\param [in] handedness Whether the provided view projection matrices use left handed or right handed coordinate system
		\return GFSDK_HAIR_RETURN_OK is returned when camera matrices were properly set.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note It is important to set camera properly before rendering or simulation, 
				as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is possible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionality such as backface culling may behave incorrectly.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetViewProjection(
		const gfsdk_float4x4*		view, 
		const gfsdk_float4x4*		proj, 
		GFSDK_HAIR_HANDEDNESS_HINT	handedness = GFSDK_HAIR_RIGHT_HANDED,
		float						FOV = 70.0f
		) = 0;

	virtual GFSDK_HAIR_RETURNCODES SetViewProjectionForCubeMap(
		const gfsdk_float4x4 view[6], 
		const gfsdk_float4x4 proj[6], 
		const bool visibility[6],
		GFSDK_HAIR_HANDEDNESS_HINT	handedness = GFSDK_HAIR_RIGHT_HANDED
		) = 0;

	/**
		\brief set previous camera projection matrices for pixel velocity attributes, etc.
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] FOV field of view in angles.
		\param [in] handedness Whether the provided view projection matrices use left handed or right handed coordinate system
		\return GFSDK_HAIR_RETURN_OK is returned when camera matrices were properly set.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note It is important to set camera properly before rendering or simulation, 
				as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is posible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionarlity such as backface culling may behave incorrectly.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetPrevViewProjection(
		const gfsdk_float4x4*		view, 
		const gfsdk_float4x4*		proj, 
		GFSDK_HAIR_HANDEDNESS_HINT	handedness = GFSDK_HAIR_RIGHT_HANDED,
		float						FOV = 70.0f
		) = 0;

	/**
		\brief fill constant buffer for custom hair shading
		\details This function fills constant buffer data structure GFSDK_HairShaderConstantBuffer for binding custom constant buffer in connection with custom hair pixel shader.
		\param [in] hairInstanceID hair instance to render
		\param [out] pConstantBuffer The context of provided constant buffer structure will be filled.
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
		\note SetViewProjection() function should be called before using this function to get proper view/camera data in the constant buffer.
	*/
	virtual GFSDK_HAIR_RETURNCODES PrepareShaderConstantBuffer(
		const GFSDK_HairInstanceID		hairInstanceID, 
		GFSDK_HairShaderConstantBuffer* pConstantBuffer
		) = 0;

	/** 
		\brief render a hair instance to the current render target.
		\details This function does the main hair rendering.  
		\param [in] hairInstanceID hair instance to render
		\param [in] pShaderSettings users can customize various aspects of hair shaders using GFSDK_HairShaderSettings.
		\return GFSDK_HAIR_RETURN_OK is returned if hair rendering finishes successfully.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES RenderHairs( 
		const GFSDK_HairInstanceID		hairInstanceID, 
		const GFSDK_HairShaderSettings* pShaderSettings = 0
		) = 0;		

	/**
		\brief render visualization functions
		\param [in] hairInstanceID hair instance to render
		\details This function renders all the auxiliary visualization options given in the GFSDK_Hair_InstanceDescriptor.
			These can be useful for debugging and verification purposes.
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/	
	virtual GFSDK_HAIR_RETURNCODES RenderVisualization( 
		const GFSDK_HairInstanceID		hairInstanceId
		) = 0;

	/*=============================================================================================
		CUSTOM MSAA FUNCTIONS

		Some engines may not have MSAA enabled render targets.
		In this case, user can use custom MSAA render targets just for hairworks, and composite the result
		to non-msaa buffer. 
		This may be particularly useful for non-MSAA deferred rendering solutions.
	=============================================================================================*/

	/**
		\brief Prepare custom MSAA buffer, and switch render target to this custom buffer.
		\param [in] sampleCount number of MSAA samples.  If 0, we simply disable msaa.
			Allowed sample counts are 1, 2, 4, 8.
		\param [in] depthCompareLess Whether depth test is 'less than' or 'greater than' for proper depth resolve.
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
	*/	
	virtual GFSDK_HAIR_RETURNCODES StartMSAARendering(UINT sampleCount, bool depthCompareLess) = 0;

	/**
		\brief Once all hairworks render calls are finished, use this function to switch back to original render target and perform MSAA resolve.
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
	*/	
	virtual GFSDK_HAIR_RETURNCODES FinishMSAARendering() = 0;
	
	/**
		\brief Draw MSAA resolved color buffer to current render target.
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
	*/	
	virtual GFSDK_HAIR_RETURNCODES DrawMSAAColor() = 0;

	/**
		\brief Draw MSAA resolved depth buffer to current depth target.
		\param [in] emitPartialFragment when true, we write depth from partial fragment (alpha < 1.0).
		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
	*/	
	virtual GFSDK_HAIR_RETURNCODES DrawMSAAPostDepth(bool emitPartialFramgment = true) = 0;

	/*=============================================================================================
		UTILITY FUNCTIONS

		Use the following functions to query further info/states of the HairWorks runtime.
		These functions are not need to just run the HairWorks, but could be useful for debugging/profiling purposes.
	=============================================================================================*/
	/**
		\brief Use this function to get the build string which includes build location and date/time
	*/
	virtual gfsdk_cstr GetBuildString() = 0;

	/**
		\brief return number of guide hairs in the asset
		\param [in] assetID hair asset ID to use
		\param [out] pNumGuideHairs pointer to copy the data.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetNumGuideHairs( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					pNumGuideHairs
		) = 0;

	/**
		\brief return number of hair vertices in the asset
		\param [in] assetID hair asset ID to use
		\param [out] pNumVertices pointer to copy the data.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetNumHairVertices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					pNumVertices
		) = 0;

	/**
		\brief return number of faces of the growth mesh in the asset
		\param [in] assetID hair asset ID to use
		\param [out] pNumFaces pointer to copy the data.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetNumFaces( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					pNumFaces
		) = 0;

	/**
		\brief get control vertices of the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pVertices data to copy from the asset. It should be pre-allocated to at least number of hair control vertices * sizeof(gfsdk_float3).
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetHairVertices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_float3*				pVertices
		) = 0;

	/**
		\brief get root vertices (growth mesh vertices) of the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pVertices data to copy from the asset.  It should be pre-allocated to at least number of hair curves * sizeof(gfsdk_float3).
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetRootVertices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_float3*				pVertices
		) = 0;

	/**
		\brief get end indices from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pIndices data to copy from the asset
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetEndIndices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					pIndices
		) = 0;

	/**
		\brief get face indices from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pIndices data to copy from the asset
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetFaceIndices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					pIndices
		) = 0;

	/**
		\brief get face uvs from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pUVs data to copy from the asset
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetFaceUVs( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_float2*				pUVs
		) = 0;

	/**
		\brief changes bone order based on new bone names
		\param [in] assetID hair asset ID to apply bone remapping
		\param[in] ppBoneNames bone names used in new ordering
		\param[in] numBones number of bones in new ordering

		\detail This function changes bone ordering of current hair asset identified by assetID.
			In case in-game bone orders are different, or when game uses reduced number of bones compared to asset stored in .apx file,
			users can change (and optionally resave the asset) bone settings with this API.

		\return GFSDK_HAIR_RETURN_OK is returned if it succeeded.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.

		\note If original bone name from asset does not exist in new bone names, behaviors for hair vertices affected by the omitted bones can be undefined.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetBoneRemapping( 
		const GFSDK_HairAssetID		assetID, 
		const gfsdk_char**			ppBoneNames, 
		gfsdk_U32					numBones 
		) = 0;

	/**
		\brief get number of bones used in the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] numBones number of bones gets written to this variable
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid and bone size was properly written.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetNumBones( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_U32*					numBones 
		) = 0;

	/**
		\brief get bone name from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [in] boneID bone id to use
		\param [out] pBoneName bone name gets copied into this variable.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid and bone name was properly written.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBoneName( 
		const GFSDK_HairAssetID		assetID, 
		const gfsdk_U32				boneID, 
		gfsdk_char*					pBoneName
		) = 0;

	/**
		\brief bind pose matrix from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [in] boneID bone id to use
		\param [out] pBindPose bind pose data to copy the matrix to.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid and bind pose data was properly written.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBindPose( 
		const GFSDK_HairAssetID		assetID, 
		const gfsdk_U32				boneID, 
		gfsdk_float4x4*				pBindPose
		) = 0;


	/**
		\brief get bone indices from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pBoneIndices bone indices array to copy from the asset
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBoneIndices( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_float4*				pBoneIndices
		) = 0;

	/**
		\brief get bone weights from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] pBoneIndices bone weights array to copy from the asset
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBoneWeights( 
		const GFSDK_HairAssetID		assetID, 
		gfsdk_float4*				pBoneWeights
		) = 0;

	/**
		\brief get texture file name from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [in] textureID texture id to use
		\param [out] pTextureName texture name gets copied into this variable.
		\return GFSDK_HAIR_RETURN_OK is returned when hair asset id is valid and texture name was properly written.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if assetID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetTextureName( 
		const GFSDK_HairAssetID			assetID, 
		const GFSDK_HAIR_TEXTURE_TYPE	textureID, 
		gfsdk_char*						pTextureName
		) = 0;

	/*
		\brief get statistics about a hair instance
		\param[in] pd3dContext d3dcontext where this stat would be computed
		\param[in] instanceID hair instance id to pull stats from
		\param[out] pStats pointer to GFSDK_HairStats struct
		\return GFSDK_HAIR_RETURN_OK is returned when hair instance id is valid and stats are computed.
				GFSDK_HAIR_RETURN_INVALID_PARAMETERS is returned if hairInstanceID is invalid.
				GFSDK_HAIR_RETURN_FAIL is returned if it failed.
	*/
	virtual GFSDK_HAIR_RETURNCODES ComputeStats(
		const GFSDK_HairInstanceID		instanceID, 
		GFSDK_HairStats*				pStats
		) = 0;

};

/*
	\brief Use this function to load HairSDK from dll
	\param [in] dllPath Path to the GFSDK_HairWorks.*.dll file
	\param [in] version Version should match between this header and the dll
	\param [in] pCustomAllocator If not NULL, HairWorks will use this allocator for all internal CPU memory allocation
	\param [in] pCustomLogHandler If not NULL, HairWorks will use this log handler to process the log messages
	\param [in] debugMode HairWorks internally use only, this value must be zero
	\return The HairWorks SDK instance pointer will be returned.
	*/
inline GFSDK_HairSDK* GFSDK_LoadHairSDK(
	gfsdk_cstr				dllPath,
	gfsdk_U32				version = GFSDK_HAIRWORKS_VERSION,
	gfsdk_new_delete_t*		pCustomAllocator = 0,
	GFSDK_HAIR_LogHandler*	pCustomLogHandler = 0,
    int						debugMode = 0
	)
{
	typedef GFSDK_HairSDK* (__cdecl * GET_HAIR_SDK_PROC)(gfsdk_U32, gfsdk_new_delete_t*, GFSDK_HAIR_LogHandler*, int);

	HMODULE hairDLLModule = LoadLibraryA(dllPath);

	if (hairDLLModule)
	{
		GET_HAIR_SDK_PROC pCreateProc = (GET_HAIR_SDK_PROC)GetProcAddress(hairDLLModule, "GFSDK_HairWorks_CreateClassInterface");

		if (!pCreateProc)
		{
			FreeLibrary( hairDLLModule);
			hairDLLModule = NULL;
			if (pCustomLogHandler) pCustomLogHandler->Log(GFSDK_HAIR_LOG_ERROR, "HairWorks dll file not found", 0, 0);
		}
		else
			return pCreateProc(version, pCustomAllocator, pCustomLogHandler, debugMode);
	}

	return 0;
}

extern "C"
{
	// Entry point to create the class based interface
	__GFSDK_EXPORT__ GFSDK_HairSDK *GFSDK_HairWorks_CreateClassInterface(gfsdk_U32 version_number, gfsdk_new_delete_t* pCustomAllocator, GFSDK_HAIR_LogHandler* pCustomLogHandler, int debugMode);
}

#endif
